class ObjectCollisionMatrix{constructor(){this.matrix={}}get(e,t){let{id:s}=e,{id:i}=t;if(i>s){const e=i;i=s,s=e}return`${s}-${i}`in this.matrix}set(e,t,s){let{id:i}=e,{id:o}=t;if(o>i){const e=o;o=i,i=e}s?this.matrix[`${i}-${o}`]=!0:delete this.matrix[`${i}-${o}`]}reset(){this.matrix={}}setNumObjects(e){}}class Mat3{constructor(e){void 0===e&&(e=[0,0,0,0,0,0,0,0,0]),this.elements=e}identity(){const e=this.elements;e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1}setZero(){const e=this.elements;e[0]=0,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=0,e[6]=0,e[7]=0,e[8]=0}setTrace(e){const t=this.elements;t[0]=e.x,t[4]=e.y,t[8]=e.z}getTrace(e){void 0===e&&(e=new Vec3);const t=this.elements;return e.x=t[0],e.y=t[4],e.z=t[8],e}vmult(e,t){void 0===t&&(t=new Vec3);const s=this.elements,i=e.x,o=e.y,n=e.z;return t.x=s[0]*i+s[1]*o+s[2]*n,t.y=s[3]*i+s[4]*o+s[5]*n,t.z=s[6]*i+s[7]*o+s[8]*n,t}smult(e){for(let t=0;t<this.elements.length;t++)this.elements[t]*=e}mmult(e,t){void 0===t&&(t=new Mat3);const s=this.elements,i=e.elements,o=t.elements,n=s[0],r=s[1],l=s[2],h=s[3],d=s[4],p=s[5],u=s[6],m=s[7],v=s[8],y=i[0],g=i[1],x=i[2],f=i[3],w=i[4],B=i[5],_=i[6],S=i[7],V=i[8];return o[0]=n*y+r*f+l*_,o[1]=n*g+r*w+l*S,o[2]=n*x+r*B+l*V,o[3]=h*y+d*f+p*_,o[4]=h*g+d*w+p*S,o[5]=h*x+d*B+p*V,o[6]=u*y+m*f+v*_,o[7]=u*g+m*w+v*S,o[8]=u*x+m*B+v*V,t}scale(e,t){void 0===t&&(t=new Mat3);const s=this.elements,i=t.elements;for(let t=0;3!==t;t++)i[3*t+0]=e.x*s[3*t+0],i[3*t+1]=e.y*s[3*t+1],i[3*t+2]=e.z*s[3*t+2];return t}solve(e,t){void 0===t&&(t=new Vec3);const s=[];let i,o;for(i=0;i<12;i++)s.push(0);for(i=0;i<3;i++)for(o=0;o<3;o++)s[i+4*o]=this.elements[i+3*o];s[3]=e.x,s[7]=e.y,s[11]=e.z;let n=3;const r=n;let l;let h;do{if(i=r-n,0===s[i+4*i])for(o=i+1;o<r;o++)if(0!==s[i+4*o]){l=4;do{h=4-l,s[h+4*i]+=s[h+4*o]}while(--l);break}if(0!==s[i+4*i])for(o=i+1;o<r;o++){const e=s[i+4*o]/s[i+4*i];l=4;do{h=4-l,s[h+4*o]=h<=i?0:s[h+4*o]-s[h+4*i]*e}while(--l)}}while(--n);if(t.z=s[11]/s[10],t.y=(s[7]-s[6]*t.z)/s[5],t.x=(s[3]-s[2]*t.z-s[1]*t.y)/s[0],isNaN(t.x)||isNaN(t.y)||isNaN(t.z)||t.x===1/0||t.y===1/0||t.z===1/0)throw`Could not solve equation! Got x=[${t.toString()}], b=[${e.toString()}], A=[${this.toString()}]`;return t}e(e,t,s){if(void 0===s)return this.elements[t+3*e];this.elements[t+3*e]=s}copy(e){for(let t=0;t<e.elements.length;t++)this.elements[t]=e.elements[t];return this}toString(){let e="";for(let t=0;t<9;t++)e+=this.elements[t]+",";return e}reverse(e){void 0===e&&(e=new Mat3);const t=reverse_eqns;let s,i;for(s=0;s<3;s++)for(i=0;i<3;i++)t[s+6*i]=this.elements[s+3*i];t[3]=1,t[9]=0,t[15]=0,t[4]=0,t[10]=1,t[16]=0,t[5]=0,t[11]=0,t[17]=1;let o=3;const n=o;let r;let l;do{if(s=n-o,0===t[s+6*s])for(i=s+1;i<n;i++)if(0!==t[s+6*i]){r=6;do{l=6-r,t[l+6*s]+=t[l+6*i]}while(--r);break}if(0!==t[s+6*s])for(i=s+1;i<n;i++){const e=t[s+6*i]/t[s+6*s];r=6;do{l=6-r,t[l+6*i]=l<=s?0:t[l+6*i]-t[l+6*s]*e}while(--r)}}while(--o);s=2;do{i=s-1;do{const e=t[s+6*i]/t[s+6*s];r=6;do{l=6-r,t[l+6*i]=t[l+6*i]-t[l+6*s]*e}while(--r)}while(i--)}while(--s);s=2;do{const e=1/t[s+6*s];r=6;do{l=6-r,t[l+6*s]=t[l+6*s]*e}while(--r)}while(s--);s=2;do{i=2;do{if(l=t[3+i+6*s],isNaN(l)||l===1/0)throw`Could not reverse! A=[${this.toString()}]`;e.e(s,i,l)}while(i--)}while(s--);return e}setRotationFromQuaternion(e){const t=e.x,s=e.y,i=e.z,o=e.w,n=t+t,r=s+s,l=i+i,h=t*n,d=t*r,p=t*l,u=s*r,m=s*l,v=i*l,y=o*n,g=o*r,x=o*l,f=this.elements;return f[0]=1-(u+v),f[1]=d-x,f[2]=p+g,f[3]=d+x,f[4]=1-(h+v),f[5]=m-y,f[6]=p-g,f[7]=m+y,f[8]=1-(h+u),this}transpose(e){void 0===e&&(e=new Mat3);const t=this.elements,s=e.elements;let i;return s[0]=t[0],s[4]=t[4],s[8]=t[8],i=t[1],s[1]=t[3],s[3]=i,i=t[2],s[2]=t[6],s[6]=i,i=t[5],s[5]=t[7],s[7]=i,e}}const reverse_eqns=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];class Vec3{constructor(e,t,s){void 0===e&&(e=0),void 0===t&&(t=0),void 0===s&&(s=0),this.x=e,this.y=t,this.z=s}cross(e,t){void 0===t&&(t=new Vec3);const s=e.x,i=e.y,o=e.z,n=this.x,r=this.y,l=this.z;return t.x=r*o-l*i,t.y=l*s-n*o,t.z=n*i-r*s,t}set(e,t,s){return this.x=e,this.y=t,this.z=s,this}setZero(){this.x=this.y=this.z=0}vadd(e,t){if(!t)return new Vec3(this.x+e.x,this.y+e.y,this.z+e.z);t.x=e.x+this.x,t.y=e.y+this.y,t.z=e.z+this.z}vsub(e,t){if(!t)return new Vec3(this.x-e.x,this.y-e.y,this.z-e.z);t.x=this.x-e.x,t.y=this.y-e.y,t.z=this.z-e.z}crossmat(){return new Mat3([0,-this.z,this.y,this.z,0,-this.x,-this.y,this.x,0])}normalize(){const e=this.x,t=this.y,s=this.z,i=Math.sqrt(e*e+t*t+s*s);if(i>0){const e=1/i;this.x*=e,this.y*=e,this.z*=e}else this.x=0,this.y=0,this.z=0;return i}unit(e){void 0===e&&(e=new Vec3);const t=this.x,s=this.y,i=this.z;let o=Math.sqrt(t*t+s*s+i*i);return o>0?(o=1/o,e.x=t*o,e.y=s*o,e.z=i*o):(e.x=1,e.y=0,e.z=0),e}length(){const e=this.x,t=this.y,s=this.z;return Math.sqrt(e*e+t*t+s*s)}lengthSquared(){return this.dot(this)}distanceTo(e){const t=this.x,s=this.y,i=this.z,o=e.x,n=e.y,r=e.z;return Math.sqrt((o-t)*(o-t)+(n-s)*(n-s)+(r-i)*(r-i))}distanceSquared(e){const t=this.x,s=this.y,i=this.z,o=e.x,n=e.y,r=e.z;return(o-t)*(o-t)+(n-s)*(n-s)+(r-i)*(r-i)}scale(e,t){void 0===t&&(t=new Vec3);const s=this.x,i=this.y,o=this.z;return t.x=e*s,t.y=e*i,t.z=e*o,t}vmul(e,t){return void 0===t&&(t=new Vec3),t.x=e.x*this.x,t.y=e.y*this.y,t.z=e.z*this.z,t}addScaledVector(e,t,s){return void 0===s&&(s=new Vec3),s.x=this.x+e*t.x,s.y=this.y+e*t.y,s.z=this.z+e*t.z,s}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}isZero(){return 0===this.x&&0===this.y&&0===this.z}negate(e){return void 0===e&&(e=new Vec3),e.x=-this.x,e.y=-this.y,e.z=-this.z,e}tangents(e,t){const s=this.length();if(s>0){const i=Vec3_tangents_n,o=1/s;i.set(this.x*o,this.y*o,this.z*o);const n=Vec3_tangents_randVec;Math.abs(i.x)<.9?(n.set(1,0,0),i.cross(n,e)):(n.set(0,1,0),i.cross(n,e)),i.cross(e,t)}else e.set(1,0,0),t.set(0,1,0)}toString(){return`${this.x},${this.y},${this.z}`}toArray(){return[this.x,this.y,this.z]}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}lerp(e,t,s){const i=this.x,o=this.y,n=this.z;s.x=i+(e.x-i)*t,s.y=o+(e.y-o)*t,s.z=n+(e.z-n)*t}almostEquals(e,t){return void 0===t&&(t=1e-6),!(Math.abs(this.x-e.x)>t||Math.abs(this.y-e.y)>t||Math.abs(this.z-e.z)>t)}almostZero(e){return void 0===e&&(e=1e-6),!(Math.abs(this.x)>e||Math.abs(this.y)>e||Math.abs(this.z)>e)}isAntiparallelTo(e,t){return this.negate(antip_neg),antip_neg.almostEquals(e,t)}clone(){return new Vec3(this.x,this.y,this.z)}}Vec3.ZERO=new Vec3(0,0,0),Vec3.UNIT_X=new Vec3(1,0,0),Vec3.UNIT_Y=new Vec3(0,1,0),Vec3.UNIT_Z=new Vec3(0,0,1);const Vec3_tangents_n=new Vec3,Vec3_tangents_randVec=new Vec3,antip_neg=new Vec3;class AABB{constructor(e){void 0===e&&(e={}),this.lowerBound=new Vec3,this.upperBound=new Vec3,e.lowerBound&&this.lowerBound.copy(e.lowerBound),e.upperBound&&this.upperBound.copy(e.upperBound)}setFromPoints(e,t,s,i){const o=this.lowerBound,n=this.upperBound,r=s;o.copy(e[0]),r&&r.vmult(o,o),n.copy(o);for(let t=1;t<e.length;t++){let s=e[t];r&&(r.vmult(s,tmp$1),s=tmp$1),s.x>n.x&&(n.x=s.x),s.x<o.x&&(o.x=s.x),s.y>n.y&&(n.y=s.y),s.y<o.y&&(o.y=s.y),s.z>n.z&&(n.z=s.z),s.z<o.z&&(o.z=s.z)}return t&&(t.vadd(o,o),t.vadd(n,n)),i&&(o.x-=i,o.y-=i,o.z-=i,n.x+=i,n.y+=i,n.z+=i),this}copy(e){return this.lowerBound.copy(e.lowerBound),this.upperBound.copy(e.upperBound),this}clone(){return(new AABB).copy(this)}extend(e){this.lowerBound.x=Math.min(this.lowerBound.x,e.lowerBound.x),this.upperBound.x=Math.max(this.upperBound.x,e.upperBound.x),this.lowerBound.y=Math.min(this.lowerBound.y,e.lowerBound.y),this.upperBound.y=Math.max(this.upperBound.y,e.upperBound.y),this.lowerBound.z=Math.min(this.lowerBound.z,e.lowerBound.z),this.upperBound.z=Math.max(this.upperBound.z,e.upperBound.z)}overlaps(e){const t=this.lowerBound,s=this.upperBound,i=e.lowerBound,o=e.upperBound,n=i.x<=s.x&&s.x<=o.x||t.x<=o.x&&o.x<=s.x,r=i.y<=s.y&&s.y<=o.y||t.y<=o.y&&o.y<=s.y,l=i.z<=s.z&&s.z<=o.z||t.z<=o.z&&o.z<=s.z;return n&&r&&l}volume(){const e=this.lowerBound,t=this.upperBound;return(t.x-e.x)*(t.y-e.y)*(t.z-e.z)}contains(e){const t=this.lowerBound,s=this.upperBound,i=e.lowerBound,o=e.upperBound;return t.x<=i.x&&s.x>=o.x&&t.y<=i.y&&s.y>=o.y&&t.z<=i.z&&s.z>=o.z}getCorners(e,t,s,i,o,n,r,l){const h=this.lowerBound,d=this.upperBound;e.copy(h),t.set(d.x,h.y,h.z),s.set(d.x,d.y,h.z),i.set(h.x,d.y,d.z),o.set(d.x,h.y,d.z),n.set(h.x,d.y,h.z),r.set(h.x,h.y,d.z),l.copy(d)}toLocalFrame(e,t){const s=transformIntoFrame_corners,i=s[0],o=s[1],n=s[2],r=s[3],l=s[4],h=s[5],d=s[6],p=s[7];this.getCorners(i,o,n,r,l,h,d,p);for(let t=0;8!==t;t++){const i=s[t];e.pointToLocal(i,i)}return t.setFromPoints(s)}toWorldFrame(e,t){const s=transformIntoFrame_corners,i=s[0],o=s[1],n=s[2],r=s[3],l=s[4],h=s[5],d=s[6],p=s[7];this.getCorners(i,o,n,r,l,h,d,p);for(let t=0;8!==t;t++){const i=s[t];e.pointToWorld(i,i)}return t.setFromPoints(s)}overlapsRay(e){const{direction:t,from:s}=e,i=1/t.x,o=1/t.y,n=1/t.z,r=(this.lowerBound.x-s.x)*i,l=(this.upperBound.x-s.x)*i,h=(this.lowerBound.y-s.y)*o,d=(this.upperBound.y-s.y)*o,p=(this.lowerBound.z-s.z)*n,u=(this.upperBound.z-s.z)*n,m=Math.max(Math.max(Math.min(r,l),Math.min(h,d)),Math.min(p,u)),v=Math.min(Math.min(Math.max(r,l),Math.max(h,d)),Math.max(p,u));return!(v<0)&&!(m>v)}}const tmp$1=new Vec3,transformIntoFrame_corners=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3];class ArrayCollisionMatrix{constructor(){this.matrix=[]}get(e,t){let{index:s}=e,{index:i}=t;if(i>s){const e=i;i=s,s=e}return this.matrix[(s*(s+1)>>1)+i-1]}set(e,t,s){let{index:i}=e,{index:o}=t;if(o>i){const e=o;o=i,i=e}this.matrix[(i*(i+1)>>1)+o-1]=s?1:0}reset(){for(let e=0,t=this.matrix.length;e!==t;e++)this.matrix[e]=0}setNumObjects(e){this.matrix.length=e*(e-1)>>1}}class EventTarget{addEventListener(e,t){void 0===this._listeners&&(this._listeners={});const s=this._listeners;return void 0===s[e]&&(s[e]=[]),s[e].includes(t)||s[e].push(t),this}hasEventListener(e,t){if(void 0===this._listeners)return!1;const s=this._listeners;return!(void 0===s[e]||!s[e].includes(t))}hasAnyEventListener(e){if(void 0===this._listeners)return!1;return void 0!==this._listeners[e]}removeEventListener(e,t){if(void 0===this._listeners)return this;const s=this._listeners;if(void 0===s[e])return this;const i=s[e].indexOf(t);return-1!==i&&s[e].splice(i,1),this}dispatchEvent(e){if(void 0===this._listeners)return this;const t=this._listeners[e.type];if(void 0!==t){e.target=this;for(let s=0,i=t.length;s<i;s++)t[s].call(this,e)}return this}}class Quaternion{constructor(e,t,s,i){void 0===e&&(e=0),void 0===t&&(t=0),void 0===s&&(s=0),void 0===i&&(i=1),this.x=e,this.y=t,this.z=s,this.w=i}set(e,t,s,i){return this.x=e,this.y=t,this.z=s,this.w=i,this}toString(){return`${this.x},${this.y},${this.z},${this.w}`}toArray(){return[this.x,this.y,this.z,this.w]}setFromAxisAngle(e,t){const s=Math.sin(.5*t);return this.x=e.x*s,this.y=e.y*s,this.z=e.z*s,this.w=Math.cos(.5*t),this}toAxisAngle(e){void 0===e&&(e=new Vec3),this.normalize();const t=2*Math.acos(this.w),s=Math.sqrt(1-this.w*this.w);return s<.001?(e.x=this.x,e.y=this.y,e.z=this.z):(e.x=this.x/s,e.y=this.y/s,e.z=this.z/s),[e,t]}setFromVectors(e,t){if(e.isAntiparallelTo(t)){const t=sfv_t1,s=sfv_t2;e.tangents(t,s),this.setFromAxisAngle(t,Math.PI)}else{const s=e.cross(t);this.x=s.x,this.y=s.y,this.z=s.z,this.w=Math.sqrt(e.length()**2*t.length()**2)+e.dot(t),this.normalize()}return this}mult(e,t){void 0===t&&(t=new Quaternion);const s=this.x,i=this.y,o=this.z,n=this.w,r=e.x,l=e.y,h=e.z,d=e.w;return t.x=s*d+n*r+i*h-o*l,t.y=i*d+n*l+o*r-s*h,t.z=o*d+n*h+s*l-i*r,t.w=n*d-s*r-i*l-o*h,t}inverse(e){void 0===e&&(e=new Quaternion);const t=this.x,s=this.y,i=this.z,o=this.w;this.conjugate(e);const n=1/(t*t+s*s+i*i+o*o);return e.x*=n,e.y*=n,e.z*=n,e.w*=n,e}conjugate(e){return void 0===e&&(e=new Quaternion),e.x=-this.x,e.y=-this.y,e.z=-this.z,e.w=this.w,e}normalize(){let e=Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(e=1/e,this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}normalizeFast(){const e=(3-(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w))/2;return 0===e?(this.x=0,this.y=0,this.z=0,this.w=0):(this.x*=e,this.y*=e,this.z*=e,this.w*=e),this}vmult(e,t){void 0===t&&(t=new Vec3);const s=e.x,i=e.y,o=e.z,n=this.x,r=this.y,l=this.z,h=this.w,d=h*s+r*o-l*i,p=h*i+l*s-n*o,u=h*o+n*i-r*s,m=-n*s-r*i-l*o;return t.x=d*h+m*-n+p*-l-u*-r,t.y=p*h+m*-r+u*-n-d*-l,t.z=u*h+m*-l+d*-r-p*-n,t}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w,this}toEuler(e,t){let s,i,o;void 0===t&&(t="YZX");const n=this.x,r=this.y,l=this.z,h=this.w;if("YZX"!==t)throw new Error(`Euler order ${t} not supported yet.`);{const e=n*r+l*h;if(e>.499&&(s=2*Math.atan2(n,h),i=Math.PI/2,o=0),e<-.499&&(s=-2*Math.atan2(n,h),i=-Math.PI/2,o=0),void 0===s){const t=n*n,d=r*r,p=l*l;s=Math.atan2(2*r*h-2*n*l,1-2*d-2*p),i=Math.asin(2*e),o=Math.atan2(2*n*h-2*r*l,1-2*t-2*p)}}e.y=s,e.z=i,e.x=o}setFromEuler(e,t,s,i){void 0===i&&(i="XYZ");const o=Math.cos(e/2),n=Math.cos(t/2),r=Math.cos(s/2),l=Math.sin(e/2),h=Math.sin(t/2),d=Math.sin(s/2);return"XYZ"===i?(this.x=l*n*r+o*h*d,this.y=o*h*r-l*n*d,this.z=o*n*d+l*h*r,this.w=o*n*r-l*h*d):"YXZ"===i?(this.x=l*n*r+o*h*d,this.y=o*h*r-l*n*d,this.z=o*n*d-l*h*r,this.w=o*n*r+l*h*d):"ZXY"===i?(this.x=l*n*r-o*h*d,this.y=o*h*r+l*n*d,this.z=o*n*d+l*h*r,this.w=o*n*r-l*h*d):"ZYX"===i?(this.x=l*n*r-o*h*d,this.y=o*h*r+l*n*d,this.z=o*n*d-l*h*r,this.w=o*n*r+l*h*d):"YZX"===i?(this.x=l*n*r+o*h*d,this.y=o*h*r+l*n*d,this.z=o*n*d-l*h*r,this.w=o*n*r-l*h*d):"XZY"===i&&(this.x=l*n*r-o*h*d,this.y=o*h*r-l*n*d,this.z=o*n*d+l*h*r,this.w=o*n*r+l*h*d),this}clone(){return new Quaternion(this.x,this.y,this.z,this.w)}slerp(e,t,s){void 0===s&&(s=new Quaternion);const i=this.x,o=this.y,n=this.z,r=this.w;let l,h,d,p,u,m=e.x,v=e.y,y=e.z,g=e.w;return h=i*m+o*v+n*y+r*g,h<0&&(h=-h,m=-m,v=-v,y=-y,g=-g),1-h>1e-6?(l=Math.acos(h),d=Math.sin(l),p=Math.sin((1-t)*l)/d,u=Math.sin(t*l)/d):(p=1-t,u=t),s.x=p*i+u*m,s.y=p*o+u*v,s.z=p*n+u*y,s.w=p*r+u*g,s}integrate(e,t,s,i){void 0===i&&(i=new Quaternion);const o=e.x*s.x,n=e.y*s.y,r=e.z*s.z,l=this.x,h=this.y,d=this.z,p=this.w,u=.5*t;return i.x+=u*(o*p+n*d-r*h),i.y+=u*(n*p+r*l-o*d),i.z+=u*(r*p+o*h-n*l),i.w+=u*(-o*l-n*h-r*d),i}}const sfv_t1=new Vec3,sfv_t2=new Vec3,SHAPE_TYPES={SPHERE:1,PLANE:2,BOX:4,COMPOUND:8,CONVEXPOLYHEDRON:16,HEIGHTFIELD:32,PARTICLE:64,CYLINDER:128,TRIMESH:256};class Shape{constructor(e){void 0===e&&(e={}),this.id=Shape.idCounter++,this.type=e.type||0,this.boundingSphereRadius=0,this.collisionResponse=!e.collisionResponse||e.collisionResponse,this.collisionFilterGroup=void 0!==e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask=void 0!==e.collisionFilterMask?e.collisionFilterMask:-1,this.material=e.material?e.material:null,this.body=null}updateBoundingSphereRadius(){throw`computeBoundingSphereRadius() not implemented for shape type ${this.type}`}volume(){throw`volume() not implemented for shape type ${this.type}`}calculateLocalInertia(e,t){throw`calculateLocalInertia() not implemented for shape type ${this.type}`}calculateWorldAABB(e,t,s,i){throw`calculateWorldAABB() not implemented for shape type ${this.type}`}}Shape.idCounter=0,Shape.types=SHAPE_TYPES;class Transform{constructor(e){void 0===e&&(e={}),this.position=new Vec3,this.quaternion=new Quaternion,e.position&&this.position.copy(e.position),e.quaternion&&this.quaternion.copy(e.quaternion)}pointToLocal(e,t){return Transform.pointToLocalFrame(this.position,this.quaternion,e,t)}pointToWorld(e,t){return Transform.pointToWorldFrame(this.position,this.quaternion,e,t)}vectorToWorldFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.vmult(e,t),t}static pointToLocalFrame(e,t,s,i){return void 0===i&&(i=new Vec3),s.vsub(e,i),t.conjugate(tmpQuat$1),tmpQuat$1.vmult(i,i),i}static pointToWorldFrame(e,t,s,i){return void 0===i&&(i=new Vec3),t.vmult(s,i),i.vadd(e,i),i}static vectorToWorldFrame(e,t,s){return void 0===s&&(s=new Vec3),e.vmult(t,s),s}static vectorToLocalFrame(e,t,s,i){return void 0===i&&(i=new Vec3),t.w*=-1,t.vmult(s,i),t.w*=-1,i}}const tmpQuat$1=new Quaternion;class ConvexPolyhedron extends Shape{constructor(e){void 0===e&&(e={});const{vertices:t=[],faces:s=[],normals:i=[],axes:o,boundingSphereRadius:n}=e;super({type:Shape.types.CONVEXPOLYHEDRON}),this.vertices=t,this.faces=s,this.faceNormals=i,0===this.faceNormals.length&&this.computeNormals(),n?this.boundingSphereRadius=n:this.updateBoundingSphereRadius(),this.worldVertices=[],this.worldVerticesNeedsUpdate=!0,this.worldFaceNormals=[],this.worldFaceNormalsNeedsUpdate=!0,this.uniqueAxes=o?o.slice():null,this.uniqueEdges=[],this.computeEdges()}computeEdges(){const e=this.faces,t=this.vertices,s=this.uniqueEdges;s.length=0;const i=new Vec3;for(let o=0;o!==e.length;o++){const n=e[o],r=n.length;for(let e=0;e!==r;e++){const o=(e+1)%r;t[n[e]].vsub(t[n[o]],i),i.normalize();let l=!1;for(let e=0;e!==s.length;e++)if(s[e].almostEquals(i)||s[e].almostEquals(i)){l=!0;break}l||s.push(i.clone())}}}computeNormals(){this.faceNormals.length=this.faces.length;for(let e=0;e<this.faces.length;e++){for(let t=0;t<this.faces[e].length;t++)if(!this.vertices[this.faces[e][t]])throw new Error(`Vertex ${this.faces[e][t]} not found!`);const t=this.faceNormals[e]||new Vec3;this.getFaceNormal(e,t),t.negate(t),this.faceNormals[e]=t;const s=this.vertices[this.faces[e][0]];if(t.dot(s)<0){console.error(`.faceNormals[${e}] = Vec3(${t.toString()}) looks like it points into the shape? The vertices follow. Make sure they are ordered CCW around the normal, using the right hand rule.`);for(let t=0;t<this.faces[e].length;t++)console.warn(`.vertices[${this.faces[e][t]}] = Vec3(${this.vertices[this.faces[e][t]].toString()})`)}}}getFaceNormal(e,t){const s=this.faces[e],i=this.vertices[s[0]],o=this.vertices[s[1]],n=this.vertices[s[2]];ConvexPolyhedron.computeNormal(i,o,n,t)}static computeNormal(e,t,s,i){const o=new Vec3,n=new Vec3;t.vsub(e,n),s.vsub(t,o),o.cross(n,i),i.isZero()||i.normalize()}clipAgainstHull(e,t,s,i,o,n,r,l,h){const d=new Vec3;let p=-1,u=-Number.MAX_VALUE;for(let e=0;e<s.faces.length;e++){d.copy(s.faceNormals[e]),o.vmult(d,d);const t=d.dot(n);t>u&&(u=t,p=e)}const m=[];for(let e=0;e<s.faces[p].length;e++){const t=s.vertices[s.faces[p][e]],n=new Vec3;n.copy(t),o.vmult(n,n),i.vadd(n,n),m.push(n)}p>=0&&this.clipFaceAgainstHull(n,e,t,m,r,l,h)}findSeparatingAxis(e,t,s,i,o,n,r,l){const h=new Vec3,d=new Vec3,p=new Vec3,u=new Vec3,m=new Vec3,v=new Vec3;let y=Number.MAX_VALUE;const g=this;if(g.uniqueAxes)for(let r=0;r!==g.uniqueAxes.length;r++){s.vmult(g.uniqueAxes[r],h);const l=g.testSepAxis(h,e,t,s,i,o);if(!1===l)return!1;l<y&&(y=l,n.copy(h))}else{const l=r?r.length:g.faces.length;for(let d=0;d<l;d++){const l=r?r[d]:d;h.copy(g.faceNormals[l]),s.vmult(h,h);const p=g.testSepAxis(h,e,t,s,i,o);if(!1===p)return!1;p<y&&(y=p,n.copy(h))}}if(e.uniqueAxes)for(let r=0;r!==e.uniqueAxes.length;r++){o.vmult(e.uniqueAxes[r],d);const l=g.testSepAxis(d,e,t,s,i,o);if(!1===l)return!1;l<y&&(y=l,n.copy(d))}else{const r=l?l.length:e.faces.length;for(let h=0;h<r;h++){const r=l?l[h]:h;d.copy(e.faceNormals[r]),o.vmult(d,d);const p=g.testSepAxis(d,e,t,s,i,o);if(!1===p)return!1;p<y&&(y=p,n.copy(d))}}for(let r=0;r!==g.uniqueEdges.length;r++){s.vmult(g.uniqueEdges[r],u);for(let r=0;r!==e.uniqueEdges.length;r++)if(o.vmult(e.uniqueEdges[r],m),u.cross(m,v),!v.almostZero()){v.normalize();const r=g.testSepAxis(v,e,t,s,i,o);if(!1===r)return!1;r<y&&(y=r,n.copy(v))}}return i.vsub(t,p),p.dot(n)>0&&n.negate(n),!0}testSepAxis(e,t,s,i,o,n){ConvexPolyhedron.project(this,e,s,i,maxminA),ConvexPolyhedron.project(t,e,o,n,maxminB);const r=maxminA[0],l=maxminA[1],h=maxminB[0],d=maxminB[1];if(r<d||h<l)return!1;const p=r-d,u=h-l;return p<u?p:u}calculateLocalInertia(e,t){const s=new Vec3,i=new Vec3;this.computeLocalAABB(i,s);const o=s.x-i.x,n=s.y-i.y,r=s.z-i.z;t.x=1/12*e*(2*n*2*n+2*r*2*r),t.y=1/12*e*(2*o*2*o+2*r*2*r),t.z=1/12*e*(2*n*2*n+2*o*2*o)}getPlaneConstantOfFace(e){const t=this.faces[e],s=this.faceNormals[e],i=this.vertices[t[0]];return-s.dot(i)}clipFaceAgainstHull(e,t,s,i,o,n,r){const l=new Vec3,h=new Vec3,d=new Vec3,p=new Vec3,u=new Vec3,m=new Vec3,v=new Vec3,y=new Vec3,g=this,x=i,f=[];let w=-1,B=Number.MAX_VALUE;for(let t=0;t<g.faces.length;t++){l.copy(g.faceNormals[t]),s.vmult(l,l);const i=l.dot(e);i<B&&(B=i,w=t)}if(w<0)return;const _=g.faces[w];_.connectedFaces=[];for(let e=0;e<g.faces.length;e++)for(let t=0;t<g.faces[e].length;t++)-1!==_.indexOf(g.faces[e][t])&&e!==w&&-1===_.connectedFaces.indexOf(e)&&_.connectedFaces.push(e);const S=_.length;for(let e=0;e<S;e++){const i=g.vertices[_[e]],o=g.vertices[_[(e+1)%S]];i.vsub(o,h),d.copy(h),s.vmult(d,d),t.vadd(d,d),p.copy(this.faceNormals[w]),s.vmult(p,p),t.vadd(p,p),d.cross(p,u),u.negate(u),m.copy(i),s.vmult(m,m),t.vadd(m,m);const n=_.connectedFaces[e];v.copy(this.faceNormals[n]);const r=this.getPlaneConstantOfFace(n);y.copy(v),s.vmult(y,y);const l=r-y.dot(t);for(this.clipFaceAgainstPlane(x,f,y,l);x.length;)x.shift();for(;f.length;)x.push(f.shift())}v.copy(this.faceNormals[w]);const V=this.getPlaneConstantOfFace(w);y.copy(v),s.vmult(y,y);const A=V-y.dot(t);for(let e=0;e<x.length;e++){let t=y.dot(x[e])+A;if(t<=o&&(console.log(`clamped: depth=${t} to minDist=${o}`),t=o),t<=n){const s=x[e];if(t<=1e-6){const e={point:s,normal:y,depth:t};r.push(e)}}}}clipFaceAgainstPlane(e,t,s,i){let o,n;const r=e.length;if(r<2)return t;let l=e[e.length-1],h=e[0];o=s.dot(l)+i;for(let d=0;d<r;d++){if(h=e[d],n=s.dot(h)+i,o<0)if(n<0){const e=new Vec3;e.copy(h),t.push(e)}else{const e=new Vec3;l.lerp(h,o/(o-n),e),t.push(e)}else if(n<0){const e=new Vec3;l.lerp(h,o/(o-n),e),t.push(e),t.push(h)}l=h,o=n}return t}computeWorldVertices(e,t){for(;this.worldVertices.length<this.vertices.length;)this.worldVertices.push(new Vec3);const s=this.vertices,i=this.worldVertices;for(let o=0;o!==this.vertices.length;o++)t.vmult(s[o],i[o]),e.vadd(i[o],i[o]);this.worldVerticesNeedsUpdate=!1}computeLocalAABB(e,t){const s=this.vertices;e.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),t.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let i=0;i<this.vertices.length;i++){const o=s[i];o.x<e.x?e.x=o.x:o.x>t.x&&(t.x=o.x),o.y<e.y?e.y=o.y:o.y>t.y&&(t.y=o.y),o.z<e.z?e.z=o.z:o.z>t.z&&(t.z=o.z)}}computeWorldFaceNormals(e){const t=this.faceNormals.length;for(;this.worldFaceNormals.length<t;)this.worldFaceNormals.push(new Vec3);const s=this.faceNormals,i=this.worldFaceNormals;for(let o=0;o!==t;o++)e.vmult(s[o],i[o]);this.worldFaceNormalsNeedsUpdate=!1}updateBoundingSphereRadius(){let e=0;const t=this.vertices;for(let s=0;s!==t.length;s++){const i=t[s].lengthSquared();i>e&&(e=i)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,s,i){const o=this.vertices;let n,r,l,h,d,p,u=new Vec3;for(let s=0;s<o.length;s++){u.copy(o[s]),t.vmult(u,u),e.vadd(u,u);const i=u;(void 0===n||i.x<n)&&(n=i.x),(void 0===h||i.x>h)&&(h=i.x),(void 0===r||i.y<r)&&(r=i.y),(void 0===d||i.y>d)&&(d=i.y),(void 0===l||i.z<l)&&(l=i.z),(void 0===p||i.z>p)&&(p=i.z)}s.set(n,r,l),i.set(h,d,p)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}getAveragePointLocal(e){void 0===e&&(e=new Vec3);const t=this.vertices;for(let s=0;s<t.length;s++)e.vadd(t[s],e);return e.scale(1/t.length,e),e}transformAllPoints(e,t){const s=this.vertices.length,i=this.vertices;if(t){for(let e=0;e<s;e++){const s=i[e];t.vmult(s,s)}for(let e=0;e<this.faceNormals.length;e++){const s=this.faceNormals[e];t.vmult(s,s)}}if(e)for(let t=0;t<s;t++){const s=i[t];s.vadd(e,s)}}pointIsInside(e){const t=this.vertices,s=this.faces,i=this.faceNormals,o=new Vec3;this.getAveragePointLocal(o);for(let n=0;n<this.faces.length;n++){let r=i[n];const l=t[s[n][0]],h=new Vec3;e.vsub(l,h);const d=r.dot(h),p=new Vec3;o.vsub(l,p);const u=r.dot(p);if(d<0&&u>0||d>0&&u<0)return!1}return-1}static project(e,t,s,i,o){const n=e.vertices.length,r=project_localAxis;let l=0,h=0;const d=project_localOrigin,p=e.vertices;d.setZero(),Transform.vectorToLocalFrame(s,i,t,r),Transform.pointToLocalFrame(s,i,d,d);const u=d.dot(r);h=l=p[0].dot(r);for(let e=1;e<n;e++){const t=p[e].dot(r);t>l&&(l=t),t<h&&(h=t)}if(h-=u,l-=u,h>l){const e=h;h=l,l=e}o[0]=l,o[1]=h}}const maxminA=[],maxminB=[],project_worldVertex=new Vec3,project_localAxis=new Vec3,project_localOrigin=new Vec3;class Box extends Shape{constructor(e){super({type:Shape.types.BOX}),this.halfExtents=e,this.convexPolyhedronRepresentation=null,this.updateConvexPolyhedronRepresentation(),this.updateBoundingSphereRadius()}updateConvexPolyhedronRepresentation(){const e=this.halfExtents.x,t=this.halfExtents.y,s=this.halfExtents.z,i=Vec3,o=[new i(-e,-t,-s),new i(e,-t,-s),new i(e,t,-s),new i(-e,t,-s),new i(-e,-t,s),new i(e,-t,s),new i(e,t,s),new i(-e,t,s)],n=[new i(0,0,1),new i(0,1,0),new i(1,0,0)],r=new ConvexPolyhedron({vertices:o,faces:[[3,2,1,0],[4,5,6,7],[5,4,0,1],[2,3,7,6],[0,4,7,3],[1,2,6,5]],axes:n});this.convexPolyhedronRepresentation=r,r.material=this.material}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),Box.calculateInertia(this.halfExtents,e,t),t}static calculateInertia(e,t,s){const i=e;s.x=1/12*t*(2*i.y*2*i.y+2*i.z*2*i.z),s.y=1/12*t*(2*i.x*2*i.x+2*i.z*2*i.z),s.z=1/12*t*(2*i.y*2*i.y+2*i.x*2*i.x)}getSideNormals(e,t){const s=e,i=this.halfExtents;if(s[0].set(i.x,0,0),s[1].set(0,i.y,0),s[2].set(0,0,i.z),s[3].set(-i.x,0,0),s[4].set(0,-i.y,0),s[5].set(0,0,-i.z),void 0!==t)for(let e=0;e!==s.length;e++)t.vmult(s[e],s[e]);return s}volume(){return 8*this.halfExtents.x*this.halfExtents.y*this.halfExtents.z}updateBoundingSphereRadius(){this.boundingSphereRadius=this.halfExtents.length()}forEachWorldCorner(e,t,s){const i=this.halfExtents,o=[[i.x,i.y,i.z],[-i.x,i.y,i.z],[-i.x,-i.y,i.z],[-i.x,-i.y,-i.z],[i.x,-i.y,-i.z],[i.x,i.y,-i.z],[-i.x,i.y,-i.z],[i.x,-i.y,i.z]];for(let i=0;i<o.length;i++)worldCornerTempPos.set(o[i][0],o[i][1],o[i][2]),t.vmult(worldCornerTempPos,worldCornerTempPos),e.vadd(worldCornerTempPos,worldCornerTempPos),s(worldCornerTempPos.x,worldCornerTempPos.y,worldCornerTempPos.z)}calculateWorldAABB(e,t,s,i){const o=this.halfExtents;worldCornersTemp[0].set(o.x,o.y,o.z),worldCornersTemp[1].set(-o.x,o.y,o.z),worldCornersTemp[2].set(-o.x,-o.y,o.z),worldCornersTemp[3].set(-o.x,-o.y,-o.z),worldCornersTemp[4].set(o.x,-o.y,-o.z),worldCornersTemp[5].set(o.x,o.y,-o.z),worldCornersTemp[6].set(-o.x,o.y,-o.z),worldCornersTemp[7].set(o.x,-o.y,o.z);const n=worldCornersTemp[0];t.vmult(n,n),e.vadd(n,n),i.copy(n),s.copy(n);for(let o=1;o<8;o++){const n=worldCornersTemp[o];t.vmult(n,n),e.vadd(n,n);const r=n.x,l=n.y,h=n.z;r>i.x&&(i.x=r),l>i.y&&(i.y=l),h>i.z&&(i.z=h),r<s.x&&(s.x=r),l<s.y&&(s.y=l),h<s.z&&(s.z=h)}}}const worldCornerTempPos=new Vec3,worldCornersTemp=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3],BODY_TYPES={DYNAMIC:1,STATIC:2,KINEMATIC:4},BODY_SLEEP_STATES={AWAKE:0,SLEEPY:1,SLEEPING:2};class Body extends EventTarget{constructor(e){void 0===e&&(e={}),super(),this.id=Body.idCounter++,this.index=-1,this.world=null,this.vlambda=new Vec3,this.collisionFilterGroup="number"==typeof e.collisionFilterGroup?e.collisionFilterGroup:1,this.collisionFilterMask="number"==typeof e.collisionFilterMask?e.collisionFilterMask:-1,this.collisionResponse="boolean"!=typeof e.collisionResponse||e.collisionResponse,this.position=new Vec3,this.previousPosition=new Vec3,this.interpolatedPosition=new Vec3,this.initPosition=new Vec3,e.position&&(this.position.copy(e.position),this.previousPosition.copy(e.position),this.interpolatedPosition.copy(e.position),this.initPosition.copy(e.position)),this.velocity=new Vec3,e.velocity&&this.velocity.copy(e.velocity),this.initVelocity=new Vec3,this.force=new Vec3;const t="number"==typeof e.mass?e.mass:0;this.mass=t,this.invMass=t>0?1/t:0,this.material=e.material||null,this.linearDamping="number"==typeof e.linearDamping?e.linearDamping:.01,this.type=t<=0?Body.STATIC:Body.DYNAMIC,typeof e.type==typeof Body.STATIC&&(this.type=e.type),this.allowSleep=void 0===e.allowSleep||e.allowSleep,this.sleepState=Body.AWAKE,this.sleepSpeedLimit=void 0!==e.sleepSpeedLimit?e.sleepSpeedLimit:.1,this.sleepTimeLimit=void 0!==e.sleepTimeLimit?e.sleepTimeLimit:1,this.timeLastSleepy=0,this.wakeUpAfterNarrowphase=!1,this.torque=new Vec3,this.quaternion=new Quaternion,this.initQuaternion=new Quaternion,this.previousQuaternion=new Quaternion,this.interpolatedQuaternion=new Quaternion,e.quaternion&&(this.quaternion.copy(e.quaternion),this.initQuaternion.copy(e.quaternion),this.previousQuaternion.copy(e.quaternion),this.interpolatedQuaternion.copy(e.quaternion)),this.angularVelocity=new Vec3,e.angularVelocity&&this.angularVelocity.copy(e.angularVelocity),this.initAngularVelocity=new Vec3,this.shapes=[],this.shapeOffsets=[],this.shapeOrientations=[],this.inertia=new Vec3,this.invInertia=new Vec3,this.invInertiaWorld=new Mat3,this.invMassSolve=0,this.invInertiaSolve=new Vec3,this.invInertiaWorldSolve=new Mat3,this.fixedRotation=void 0!==e.fixedRotation&&e.fixedRotation,this.angularDamping=void 0!==e.angularDamping?e.angularDamping:.01,this.linearFactor=new Vec3(1,1,1),e.linearFactor&&this.linearFactor.copy(e.linearFactor),this.angularFactor=new Vec3(1,1,1),e.angularFactor&&this.angularFactor.copy(e.angularFactor),this.aabb=new AABB,this.aabbNeedsUpdate=!0,this.boundingRadius=0,this.wlambda=new Vec3,this.isTrigger=Boolean(e.isTrigger),e.shape&&this.addShape(e.shape),this.updateMassProperties()}wakeUp(){const e=this.sleepState;this.sleepState=Body.AWAKE,this.wakeUpAfterNarrowphase=!1,e===Body.SLEEPING&&this.dispatchEvent(Body.wakeupEvent)}sleep(){this.sleepState=Body.SLEEPING,this.velocity.set(0,0,0),this.angularVelocity.set(0,0,0),this.wakeUpAfterNarrowphase=!1}sleepTick(e){if(this.allowSleep){const t=this.sleepState,s=this.velocity.lengthSquared()+this.angularVelocity.lengthSquared(),i=this.sleepSpeedLimit**2;t===Body.AWAKE&&s<i?(this.sleepState=Body.SLEEPY,this.timeLastSleepy=e,this.dispatchEvent(Body.sleepyEvent)):t===Body.SLEEPY&&s>i?this.wakeUp():t===Body.SLEEPY&&e-this.timeLastSleepy>this.sleepTimeLimit&&(this.sleep(),this.dispatchEvent(Body.sleepEvent))}}updateSolveMassProperties(){this.sleepState===Body.SLEEPING||this.type===Body.KINEMATIC?(this.invMassSolve=0,this.invInertiaSolve.setZero(),this.invInertiaWorldSolve.setZero()):(this.invMassSolve=this.invMass,this.invInertiaSolve.copy(this.invInertia),this.invInertiaWorldSolve.copy(this.invInertiaWorld))}pointToLocalFrame(e,t){return void 0===t&&(t=new Vec3),e.vsub(this.position,t),this.quaternion.conjugate().vmult(t,t),t}vectorToLocalFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.conjugate().vmult(e,t),t}pointToWorldFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.vmult(e,t),t.vadd(this.position,t),t}vectorToWorldFrame(e,t){return void 0===t&&(t=new Vec3),this.quaternion.vmult(e,t),t}addShape(e,t,s){const i=new Vec3,o=new Quaternion;return t&&i.copy(t),s&&o.copy(s),this.shapes.push(e),this.shapeOffsets.push(i),this.shapeOrientations.push(o),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=this,this}removeShape(e){const t=this.shapes.indexOf(e);return-1===t?(console.warn("Shape does not belong to the body"),this):(this.shapes.splice(t,1),this.shapeOffsets.splice(t,1),this.shapeOrientations.splice(t,1),this.updateMassProperties(),this.updateBoundingRadius(),this.aabbNeedsUpdate=!0,e.body=null,this)}updateBoundingRadius(){const e=this.shapes,t=this.shapeOffsets,s=e.length;let i=0;for(let o=0;o!==s;o++){const s=e[o];s.updateBoundingSphereRadius();const n=t[o].length(),r=s.boundingSphereRadius;n+r>i&&(i=n+r)}this.boundingRadius=i}updateAABB(){const e=this.shapes,t=this.shapeOffsets,s=this.shapeOrientations,i=e.length,o=tmpVec,n=tmpQuat,r=this.quaternion,l=this.aabb,h=updateAABB_shapeAABB;for(let d=0;d!==i;d++){const i=e[d];r.vmult(t[d],o),o.vadd(this.position,o),r.mult(s[d],n),i.calculateWorldAABB(o,n,h.lowerBound,h.upperBound),0===d?l.copy(h):l.extend(h)}this.aabbNeedsUpdate=!1}updateInertiaWorld(e){const t=this.invInertia;if(t.x!==t.y||t.y!==t.z||e){const e=uiw_m1,s=uiw_m2;e.setRotationFromQuaternion(this.quaternion),e.transpose(s),e.scale(t,e),e.mmult(s,this.invInertiaWorld)}else;}applyForce(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;this.sleepState===Body.SLEEPING&&this.wakeUp();const s=Body_applyForce_rotForce;t.cross(e,s),this.force.vadd(e,this.force),this.torque.vadd(s,this.torque)}applyLocalForce(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;const s=Body_applyLocalForce_worldForce,i=Body_applyLocalForce_relativePointWorld;this.vectorToWorldFrame(e,s),this.vectorToWorldFrame(t,i),this.applyForce(s,i)}applyTorque(e){this.type===Body.DYNAMIC&&(this.sleepState===Body.SLEEPING&&this.wakeUp(),this.torque.vadd(e,this.torque))}applyImpulse(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;this.sleepState===Body.SLEEPING&&this.wakeUp();const s=t,i=Body_applyImpulse_velo;i.copy(e),i.scale(this.invMass,i),this.velocity.vadd(i,this.velocity);const o=Body_applyImpulse_rotVelo;s.cross(e,o),this.invInertiaWorld.vmult(o,o),this.angularVelocity.vadd(o,this.angularVelocity)}applyLocalImpulse(e,t){if(void 0===t&&(t=new Vec3),this.type!==Body.DYNAMIC)return;const s=Body_applyLocalImpulse_worldImpulse,i=Body_applyLocalImpulse_relativePoint;this.vectorToWorldFrame(e,s),this.vectorToWorldFrame(t,i),this.applyImpulse(s,i)}updateMassProperties(){const e=Body_updateMassProperties_halfExtents;this.invMass=this.mass>0?1/this.mass:0;const t=this.inertia,s=this.fixedRotation;this.updateAABB(),e.set((this.aabb.upperBound.x-this.aabb.lowerBound.x)/2,(this.aabb.upperBound.y-this.aabb.lowerBound.y)/2,(this.aabb.upperBound.z-this.aabb.lowerBound.z)/2),Box.calculateInertia(e,this.mass,t),this.invInertia.set(t.x>0&&!s?1/t.x:0,t.y>0&&!s?1/t.y:0,t.z>0&&!s?1/t.z:0),this.updateInertiaWorld(!0)}getVelocityAtWorldPoint(e,t){const s=new Vec3;return e.vsub(this.position,s),this.angularVelocity.cross(s,t),this.velocity.vadd(t,t),t}integrate(e,t,s){if(this.previousPosition.copy(this.position),this.previousQuaternion.copy(this.quaternion),this.type!==Body.DYNAMIC&&this.type!==Body.KINEMATIC||this.sleepState===Body.SLEEPING)return;const i=this.velocity,o=this.angularVelocity,n=this.position,r=this.force,l=this.torque,h=this.quaternion,d=this.invMass,p=this.invInertiaWorld,u=this.linearFactor,m=d*e;i.x+=r.x*m*u.x,i.y+=r.y*m*u.y,i.z+=r.z*m*u.z;const v=p.elements,y=this.angularFactor,g=l.x*y.x,x=l.y*y.y,f=l.z*y.z;o.x+=e*(v[0]*g+v[1]*x+v[2]*f),o.y+=e*(v[3]*g+v[4]*x+v[5]*f),o.z+=e*(v[6]*g+v[7]*x+v[8]*f),n.x+=i.x*e,n.y+=i.y*e,n.z+=i.z*e,h.integrate(this.angularVelocity,e,this.angularFactor,h),t&&(s?h.normalizeFast():h.normalize()),this.aabbNeedsUpdate=!0,this.updateInertiaWorld()}}Body.idCounter=0,Body.COLLIDE_EVENT_NAME="collide",Body.DYNAMIC=BODY_TYPES.DYNAMIC,Body.STATIC=BODY_TYPES.STATIC,Body.KINEMATIC=BODY_TYPES.KINEMATIC,Body.AWAKE=BODY_SLEEP_STATES.AWAKE,Body.SLEEPY=BODY_SLEEP_STATES.SLEEPY,Body.SLEEPING=BODY_SLEEP_STATES.SLEEPING,Body.wakeupEvent={type:"wakeup"},Body.sleepyEvent={type:"sleepy"},Body.sleepEvent={type:"sleep"};const tmpVec=new Vec3,tmpQuat=new Quaternion,updateAABB_shapeAABB=new AABB,uiw_m1=new Mat3,uiw_m2=new Mat3,uiw_m3=new Mat3,Body_applyForce_rotForce=new Vec3,Body_applyLocalForce_worldForce=new Vec3,Body_applyLocalForce_relativePointWorld=new Vec3,Body_applyImpulse_velo=new Vec3,Body_applyImpulse_rotVelo=new Vec3,Body_applyLocalImpulse_worldImpulse=new Vec3,Body_applyLocalImpulse_relativePoint=new Vec3,Body_updateMassProperties_halfExtents=new Vec3;class Broadphase{constructor(){this.world=null,this.useBoundingBoxes=!1,this.dirty=!0}collisionPairs(e,t,s){throw new Error("collisionPairs not implemented for this BroadPhase class!")}needBroadphaseCollision(e,t){return 0!=(e.collisionFilterGroup&t.collisionFilterMask)&&0!=(t.collisionFilterGroup&e.collisionFilterMask)&&(0==(e.type&Body.STATIC)&&e.sleepState!==Body.SLEEPING||0==(t.type&Body.STATIC)&&t.sleepState!==Body.SLEEPING)}intersectionTest(e,t,s,i){this.useBoundingBoxes?this.doBoundingBoxBroadphase(e,t,s,i):this.doBoundingSphereBroadphase(e,t,s,i)}doBoundingSphereBroadphase(e,t,s,i){const o=Broadphase_collisionPairs_r;t.position.vsub(e.position,o);const n=(e.boundingRadius+t.boundingRadius)**2;o.lengthSquared()<n&&(s.push(e),i.push(t))}doBoundingBoxBroadphase(e,t,s,i){e.aabbNeedsUpdate&&e.updateAABB(),t.aabbNeedsUpdate&&t.updateAABB(),e.aabb.overlaps(t.aabb)&&(s.push(e),i.push(t))}makePairsUnique(e,t){const s=Broadphase_makePairsUnique_temp,i=Broadphase_makePairsUnique_p1,o=Broadphase_makePairsUnique_p2,n=e.length;for(let s=0;s!==n;s++)i[s]=e[s],o[s]=t[s];e.length=0,t.length=0;for(let e=0;e!==n;e++){const t=i[e].id,n=o[e].id,r=t<n?`${t},${n}`:`${n},${t}`;s[r]=e,s.keys.push(r)}for(let n=0;n!==s.keys.length;n++){const n=s.keys.pop(),r=s[n];e.push(i[r]),t.push(o[r]),delete s[n]}}setWorld(e){}static boundingSphereCheck(e,t){const s=new Vec3;e.position.vsub(t.position,s);const i=e.shapes[0],o=t.shapes[0];return Math.pow(i.boundingSphereRadius+o.boundingSphereRadius,2)>s.lengthSquared()}aabbQuery(e,t,s){return console.warn(".aabbQuery is not implemented in this Broadphase subclass."),[]}}const Broadphase_collisionPairs_r=new Vec3;new Vec3,new Quaternion,new Vec3;const Broadphase_makePairsUnique_temp={keys:[]},Broadphase_makePairsUnique_p1=[],Broadphase_makePairsUnique_p2=[];new Vec3;class GridBroadphase extends Broadphase{constructor(e,t,s,i,o){void 0===e&&(e=new Vec3(100,100,100)),void 0===t&&(t=new Vec3(-100,-100,-100)),void 0===s&&(s=10),void 0===i&&(i=10),void 0===o&&(o=10),super(),this.nx=s,this.ny=i,this.nz=o,this.aabbMin=e,this.aabbMax=t;const n=this.nx*this.ny*this.nz;if(n<=0)throw"GridBroadphase: Each dimension's n must be >0";this.bins=[],this.binLengths=[],this.bins.length=n,this.binLengths.length=n;for(let e=0;e<n;e++)this.bins[e]=[],this.binLengths[e]=0}collisionPairs(e,t,s){const i=e.bodies.length,o=e.bodies,n=this.aabbMax,r=this.aabbMin,l=this.nx,h=this.ny,d=this.nz,p=h*d,u=d,m=n.x,v=n.y,y=n.z,g=r.x,x=r.y,f=r.z,w=l/(m-g),B=h/(v-x),_=d/(y-f),S=(m-g)/l,V=(v-x)/h,A=(y-f)/d,E=.5*Math.sqrt(S*S+V*V+A*A),C=Shape.types,T=C.SPHERE,P=C.PLANE;C.BOX,C.COMPOUND,C.CONVEXPOLYHEDRON;const I=this.bins,F=this.binLengths,R=this.bins.length;for(let e=0;e!==R;e++)F[e]=0;const z=Math.ceil;function addBoxToBins(e,t,s,i,o,n,r){let m=(e-g)*w|0,v=(t-x)*B|0,y=(s-f)*_|0,S=z((i-g)*w),V=z((o-x)*B),A=z((n-f)*_);m<0?m=0:m>=l&&(m=l-1),v<0?v=0:v>=h&&(v=h-1),y<0?y=0:y>=d&&(y=d-1),S<0?S=0:S>=l&&(S=l-1),V<0?V=0:V>=h&&(V=h-1),A<0?A=0:A>=d&&(A=d-1),m*=p,v*=u,y*=1,S*=p,V*=u,A*=1;for(let e=m;e<=S;e+=p)for(let t=v;t<=V;t+=u)for(let s=y;s<=A;s+=1){const i=e+t+s;I[i][F[i]++]=r}}for(let e=0;e!==i;e++){const t=o[e],s=t.shapes[0];switch(s.type){case T:{const e=s,i=t.position.x,o=t.position.y,n=t.position.z,r=e.radius;addBoxToBins(i-r,o-r,n-r,i+r,o+r,n+r,t);break}case P:{const e=s;e.worldNormalNeedsUpdate&&e.computeWorldNormal(t.quaternion);const i=e.worldNormal,o=g+.5*S-t.position.x,n=x+.5*V-t.position.y,r=f+.5*A-t.position.z,m=GridBroadphase_collisionPairs_d;m.set(o,n,r);for(let e=0,s=0;e!==l;e++,s+=p,m.y=n,m.x+=S)for(let e=0,o=0;e!==h;e++,o+=u,m.z=r,m.y+=V)for(let e=0,n=0;e!==d;e++,n+=1,m.z+=A)if(m.dot(i)<E){const e=s+o+n;I[e][F[e]++]=t}break}default:t.aabbNeedsUpdate&&t.updateAABB(),addBoxToBins(t.aabb.lowerBound.x,t.aabb.lowerBound.y,t.aabb.lowerBound.z,t.aabb.upperBound.x,t.aabb.upperBound.y,t.aabb.upperBound.z,t)}}for(let e=0;e!==R;e++){const i=F[e];if(i>1){const o=I[e];for(let e=0;e!==i;e++){const i=o[e];for(let n=0;n!==e;n++){const e=o[n];this.needBroadphaseCollision(i,e)&&this.intersectionTest(i,e,t,s)}}}}this.makePairsUnique(t,s)}}const GridBroadphase_collisionPairs_d=new Vec3;new Vec3;class NaiveBroadphase extends Broadphase{constructor(){super()}collisionPairs(e,t,s){const i=e.bodies,o=i.length;let n,r;for(let e=0;e!==o;e++)for(let o=0;o!==e;o++)n=i[e],r=i[o],this.needBroadphaseCollision(n,r)&&this.intersectionTest(n,r,t,s)}aabbQuery(e,t,s){void 0===s&&(s=[]);for(let i=0;i<e.bodies.length;i++){const o=e.bodies[i];o.aabbNeedsUpdate&&o.updateAABB(),o.aabb.overlaps(t)&&s.push(o)}return s}}class RaycastResult{constructor(){this.rayFromWorld=new Vec3,this.rayToWorld=new Vec3,this.hitNormalWorld=new Vec3,this.hitPointWorld=new Vec3,this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}reset(){this.rayFromWorld.setZero(),this.rayToWorld.setZero(),this.hitNormalWorld.setZero(),this.hitPointWorld.setZero(),this.hasHit=!1,this.shape=null,this.body=null,this.hitFaceIndex=-1,this.distance=-1,this.shouldStop=!1}abort(){this.shouldStop=!0}set(e,t,s,i,o,n,r){this.rayFromWorld.copy(e),this.rayToWorld.copy(t),this.hitNormalWorld.copy(s),this.hitPointWorld.copy(i),this.shape=o,this.body=n,this.distance=r}}let _Shape$types$SPHERE,_Shape$types$PLANE,_Shape$types$BOX,_Shape$types$CYLINDER,_Shape$types$CONVEXPO,_Shape$types$HEIGHTFI,_Shape$types$TRIMESH;const RAY_MODES={CLOSEST:1,ANY:2,ALL:4};_Shape$types$SPHERE=Shape.types.SPHERE,_Shape$types$PLANE=Shape.types.PLANE,_Shape$types$BOX=Shape.types.BOX,_Shape$types$CYLINDER=Shape.types.CYLINDER,_Shape$types$CONVEXPO=Shape.types.CONVEXPOLYHEDRON,_Shape$types$HEIGHTFI=Shape.types.HEIGHTFIELD,_Shape$types$TRIMESH=Shape.types.TRIMESH;class Ray{get[_Shape$types$SPHERE](){return this._intersectSphere}get[_Shape$types$PLANE](){return this._intersectPlane}get[_Shape$types$BOX](){return this._intersectBox}get[_Shape$types$CYLINDER](){return this._intersectConvex}get[_Shape$types$CONVEXPO](){return this._intersectConvex}get[_Shape$types$HEIGHTFI](){return this._intersectHeightfield}get[_Shape$types$TRIMESH](){return this._intersectTrimesh}constructor(e,t){void 0===e&&(e=new Vec3),void 0===t&&(t=new Vec3),this.from=e.clone(),this.to=t.clone(),this.direction=new Vec3,this.precision=1e-4,this.checkCollisionResponse=!0,this.skipBackfaces=!1,this.collisionFilterMask=-1,this.collisionFilterGroup=-1,this.mode=Ray.ANY,this.result=new RaycastResult,this.hasHit=!1,this.callback=e=>{}}intersectWorld(e,t){return this.mode=t.mode||Ray.ANY,this.result=t.result||new RaycastResult,this.skipBackfaces=!!t.skipBackfaces,this.collisionFilterMask=void 0!==t.collisionFilterMask?t.collisionFilterMask:-1,this.collisionFilterGroup=void 0!==t.collisionFilterGroup?t.collisionFilterGroup:-1,this.checkCollisionResponse=void 0===t.checkCollisionResponse||t.checkCollisionResponse,t.from&&this.from.copy(t.from),t.to&&this.to.copy(t.to),this.callback=t.callback||(()=>{}),this.hasHit=!1,this.result.reset(),this.updateDirection(),this.getAABB(tmpAABB$1),tmpArray.length=0,e.broadphase.aabbQuery(e,tmpAABB$1,tmpArray),this.intersectBodies(tmpArray),this.hasHit}intersectBody(e,t){t&&(this.result=t,this.updateDirection());const s=this.checkCollisionResponse;if(s&&!e.collisionResponse)return;if(0==(this.collisionFilterGroup&e.collisionFilterMask)||0==(e.collisionFilterGroup&this.collisionFilterMask))return;const i=intersectBody_xi,o=intersectBody_qi;for(let t=0,n=e.shapes.length;t<n;t++){const n=e.shapes[t];if((!s||n.collisionResponse)&&(e.quaternion.mult(e.shapeOrientations[t],o),e.quaternion.vmult(e.shapeOffsets[t],i),i.vadd(e.position,i),this.intersectShape(n,o,i,e),this.result.shouldStop))break}}intersectBodies(e,t){t&&(this.result=t,this.updateDirection());for(let t=0,s=e.length;!this.result.shouldStop&&t<s;t++)this.intersectBody(e[t])}updateDirection(){this.to.vsub(this.from,this.direction),this.direction.normalize()}intersectShape(e,t,s,i){if(distanceFromIntersection(this.from,this.direction,s)>e.boundingSphereRadius)return;const o=this[e.type];o&&o.call(this,e,t,s,i,e)}_intersectBox(e,t,s,i,o){return this._intersectConvex(e.convexPolyhedronRepresentation,t,s,i,o)}_intersectPlane(e,t,s,i,o){const n=this.from,r=this.to,l=this.direction,h=new Vec3(0,0,1);t.vmult(h,h);const d=new Vec3;n.vsub(s,d);const p=d.dot(h);r.vsub(s,d);if(p*d.dot(h)>0)return;if(n.distanceTo(r)<p)return;const u=h.dot(l);if(Math.abs(u)<this.precision)return;const m=new Vec3,v=new Vec3,y=new Vec3;n.vsub(s,m);const g=-h.dot(m)/u;l.scale(g,v),n.vadd(v,y),this.reportIntersection(h,y,o,i,-1)}getAABB(e){const{lowerBound:t,upperBound:s}=e,i=this.to,o=this.from;t.x=Math.min(i.x,o.x),t.y=Math.min(i.y,o.y),t.z=Math.min(i.z,o.z),s.x=Math.max(i.x,o.x),s.y=Math.max(i.y,o.y),s.z=Math.max(i.z,o.z)}_intersectHeightfield(e,t,s,i,o){e.data,e.elementSize;const n=intersectHeightfield_localRay;n.from.copy(this.from),n.to.copy(this.to),Transform.pointToLocalFrame(s,t,n.from,n.from),Transform.pointToLocalFrame(s,t,n.to,n.to),n.updateDirection();const r=intersectHeightfield_index;let l,h,d,p;l=h=0,d=p=e.data.length-1;const u=new AABB;n.getAABB(u),e.getIndexOfPosition(u.lowerBound.x,u.lowerBound.y,r,!0),l=Math.max(l,r[0]),h=Math.max(h,r[1]),e.getIndexOfPosition(u.upperBound.x,u.upperBound.y,r,!0),d=Math.min(d,r[0]+1),p=Math.min(p,r[1]+1);for(let r=l;r<d;r++)for(let l=h;l<p;l++){if(this.result.shouldStop)return;if(e.getAabbAtIndex(r,l,u),u.overlapsRay(n)){if(e.getConvexTrianglePillar(r,l,!1),Transform.pointToWorldFrame(s,t,e.pillarOffset,worldPillarOffset),this._intersectConvex(e.pillarConvex,t,worldPillarOffset,i,o,intersectConvexOptions),this.result.shouldStop)return;e.getConvexTrianglePillar(r,l,!0),Transform.pointToWorldFrame(s,t,e.pillarOffset,worldPillarOffset),this._intersectConvex(e.pillarConvex,t,worldPillarOffset,i,o,intersectConvexOptions)}}}_intersectSphere(e,t,s,i,o){const n=this.from,r=this.to,l=e.radius,h=(r.x-n.x)**2+(r.y-n.y)**2+(r.z-n.z)**2,d=2*((r.x-n.x)*(n.x-s.x)+(r.y-n.y)*(n.y-s.y)+(r.z-n.z)*(n.z-s.z)),p=d**2-4*h*((n.x-s.x)**2+(n.y-s.y)**2+(n.z-s.z)**2-l**2),u=Ray_intersectSphere_intersectionPoint,m=Ray_intersectSphere_normal;if(!(p<0))if(0===p)n.lerp(r,p,u),u.vsub(s,m),m.normalize(),this.reportIntersection(m,u,o,i,-1);else{const e=(-d-Math.sqrt(p))/(2*h),t=(-d+Math.sqrt(p))/(2*h);if(e>=0&&e<=1&&(n.lerp(r,e,u),u.vsub(s,m),m.normalize(),this.reportIntersection(m,u,o,i,-1)),this.result.shouldStop)return;t>=0&&t<=1&&(n.lerp(r,t,u),u.vsub(s,m),m.normalize(),this.reportIntersection(m,u,o,i,-1))}}_intersectConvex(e,t,s,i,o,n){const r=intersectConvex_normal,l=intersectConvex_vector,h=n&&n.faceList||null,d=e.faces,p=e.vertices,u=e.faceNormals,m=this.direction,v=this.from,y=this.to,g=v.distanceTo(y),x=h?h.length:d.length,f=this.result;for(let e=0;!f.shouldStop&&e<x;e++){const n=h?h[e]:e,y=d[n],x=u[n],w=t,B=s;l.copy(p[y[0]]),w.vmult(l,l),l.vadd(B,l),l.vsub(v,l),w.vmult(x,r);const _=m.dot(r);if(Math.abs(_)<this.precision)continue;const S=r.dot(l)/_;if(!(S<0)){m.scale(S,intersectPoint),intersectPoint.vadd(v,intersectPoint),a.copy(p[y[0]]),w.vmult(a,a),B.vadd(a,a);for(let e=1;!f.shouldStop&&e<y.length-1;e++){b.copy(p[y[e]]),c.copy(p[y[e+1]]),w.vmult(b,b),w.vmult(c,c),B.vadd(b,b),B.vadd(c,c);const t=intersectPoint.distanceTo(v);!Ray.pointInTriangle(intersectPoint,a,b,c)&&!Ray.pointInTriangle(intersectPoint,b,a,c)||t>g||this.reportIntersection(r,intersectPoint,o,i,n)}}}}_intersectTrimesh(e,t,s,i,o,n){const r=intersectTrimesh_normal,l=intersectTrimesh_triangles,h=intersectTrimesh_treeTransform,d=intersectConvex_vector,p=intersectTrimesh_localDirection,u=intersectTrimesh_localFrom,m=intersectTrimesh_localTo,v=intersectTrimesh_worldIntersectPoint,y=intersectTrimesh_worldNormal,g=e.indices;e.vertices;const x=this.from,f=this.to,w=this.direction;h.position.copy(s),h.quaternion.copy(t),Transform.vectorToLocalFrame(s,t,w,p),Transform.pointToLocalFrame(s,t,x,u),Transform.pointToLocalFrame(s,t,f,m),m.x*=e.scale.x,m.y*=e.scale.y,m.z*=e.scale.z,u.x*=e.scale.x,u.y*=e.scale.y,u.z*=e.scale.z,m.vsub(u,p),p.normalize();const B=u.distanceSquared(m);e.tree.rayQuery(this,h,l);for(let n=0,h=l.length;!this.result.shouldStop&&n!==h;n++){const h=l[n];e.getNormal(h,r),e.getVertex(g[3*h],a),a.vsub(u,d);const m=p.dot(r),x=r.dot(d)/m;if(x<0)continue;p.scale(x,intersectPoint),intersectPoint.vadd(u,intersectPoint),e.getVertex(g[3*h+1],b),e.getVertex(g[3*h+2],c);const f=intersectPoint.distanceSquared(u);!Ray.pointInTriangle(intersectPoint,b,a,c)&&!Ray.pointInTriangle(intersectPoint,a,b,c)||f>B||(Transform.vectorToWorldFrame(t,r,y),Transform.pointToWorldFrame(s,t,intersectPoint,v),this.reportIntersection(y,v,o,i,h))}l.length=0}reportIntersection(e,t,s,i,o){const n=this.from,r=this.to,l=n.distanceTo(t),h=this.result;if(!(this.skipBackfaces&&e.dot(this.direction)>0))switch(h.hitFaceIndex=void 0!==o?o:-1,this.mode){case Ray.ALL:this.hasHit=!0,h.set(n,r,e,t,s,i,l),h.hasHit=!0,this.callback(h);break;case Ray.CLOSEST:(l<h.distance||!h.hasHit)&&(this.hasHit=!0,h.hasHit=!0,h.set(n,r,e,t,s,i,l));break;case Ray.ANY:this.hasHit=!0,h.hasHit=!0,h.set(n,r,e,t,s,i,l),h.shouldStop=!0}}static pointInTriangle(e,t,s,i){i.vsub(t,v0),s.vsub(t,v1),e.vsub(t,v2);const o=v0.dot(v0),n=v0.dot(v1),r=v0.dot(v2),l=v1.dot(v1),h=v1.dot(v2);let d,p;return(d=l*r-n*h)>=0&&(p=o*h-n*r)>=0&&d+p<o*l-n*n}}Ray.CLOSEST=RAY_MODES.CLOSEST,Ray.ANY=RAY_MODES.ANY,Ray.ALL=RAY_MODES.ALL;const tmpAABB$1=new AABB,tmpArray=[],v1=new Vec3,v2=new Vec3,intersectBody_xi=new Vec3,intersectBody_qi=new Quaternion,intersectPoint=new Vec3,a=new Vec3,b=new Vec3,c=new Vec3;new Vec3,new RaycastResult;const intersectConvexOptions={faceList:[0]},worldPillarOffset=new Vec3,intersectHeightfield_localRay=new Ray,intersectHeightfield_index=[],Ray_intersectSphere_intersectionPoint=new Vec3,Ray_intersectSphere_normal=new Vec3,intersectConvex_normal=new Vec3,intersectConvex_minDistNormal=new Vec3,intersectConvex_minDistIntersect=new Vec3,intersectConvex_vector=new Vec3,intersectTrimesh_normal=new Vec3,intersectTrimesh_localDirection=new Vec3,intersectTrimesh_localFrom=new Vec3,intersectTrimesh_localTo=new Vec3,intersectTrimesh_worldNormal=new Vec3,intersectTrimesh_worldIntersectPoint=new Vec3;new AABB;const intersectTrimesh_triangles=[],intersectTrimesh_treeTransform=new Transform,v0=new Vec3,intersect=new Vec3;function distanceFromIntersection(e,t,s){s.vsub(e,v0);const i=v0.dot(t);t.scale(i,intersect),intersect.vadd(e,intersect);return s.distanceTo(intersect)}class SAPBroadphase extends Broadphase{static checkBounds(e,t,s){let i,o;0===s?(i=e.position.x,o=t.position.x):1===s?(i=e.position.y,o=t.position.y):2===s&&(i=e.position.z,o=t.position.z);const n=e.boundingRadius;return o-t.boundingRadius<i+n}static insertionSortX(e){for(let t=1,s=e.length;t<s;t++){const s=e[t];let i;for(i=t-1;i>=0&&!(e[i].aabb.lowerBound.x<=s.aabb.lowerBound.x);i--)e[i+1]=e[i];e[i+1]=s}return e}static insertionSortY(e){for(let t=1,s=e.length;t<s;t++){const s=e[t];let i;for(i=t-1;i>=0&&!(e[i].aabb.lowerBound.y<=s.aabb.lowerBound.y);i--)e[i+1]=e[i];e[i+1]=s}return e}static insertionSortZ(e){for(let t=1,s=e.length;t<s;t++){const s=e[t];let i;for(i=t-1;i>=0&&!(e[i].aabb.lowerBound.z<=s.aabb.lowerBound.z);i--)e[i+1]=e[i];e[i+1]=s}return e}constructor(e){super(),this.axisList=[],this.world=null,this.axisIndex=0;const t=this.axisList;this._addBodyHandler=e=>{t.push(e.body)},this._removeBodyHandler=e=>{const s=t.indexOf(e.body);-1!==s&&t.splice(s,1)},e&&this.setWorld(e)}setWorld(e){this.axisList.length=0;for(let t=0;t<e.bodies.length;t++)this.axisList.push(e.bodies[t]);e.removeEventListener("addBody",this._addBodyHandler),e.removeEventListener("removeBody",this._removeBodyHandler),e.addEventListener("addBody",this._addBodyHandler),e.addEventListener("removeBody",this._removeBodyHandler),this.world=e,this.dirty=!0}collisionPairs(e,t,s){const i=this.axisList,o=i.length,n=this.axisIndex;let r,l;for(this.dirty&&(this.sortList(),this.dirty=!1),r=0;r!==o;r++){const e=i[r];for(l=r+1;l<o;l++){const o=i[l];if(this.needBroadphaseCollision(e,o)){if(!SAPBroadphase.checkBounds(e,o,n))break;this.intersectionTest(e,o,t,s)}}}}sortList(){const e=this.axisList,t=this.axisIndex,s=e.length;for(let t=0;t!==s;t++){const s=e[t];s.aabbNeedsUpdate&&s.updateAABB()}0===t?SAPBroadphase.insertionSortX(e):1===t?SAPBroadphase.insertionSortY(e):2===t&&SAPBroadphase.insertionSortZ(e)}autoDetectAxis(){let e=0,t=0,s=0,i=0,o=0,n=0;const r=this.axisList,l=r.length,h=1/l;for(let h=0;h!==l;h++){const l=r[h],d=l.position.x;e+=d,t+=d*d;const p=l.position.y;s+=p,i+=p*p;const u=l.position.z;o+=u,n+=u*u}const d=t-e*e*h,p=i-s*s*h,u=n-o*o*h;this.axisIndex=d>p?d>u?0:2:p>u?1:2}aabbQuery(e,t,s){void 0===s&&(s=[]),this.dirty&&(this.sortList(),this.dirty=!1);const i=this.axisIndex;let o="x";1===i&&(o="y"),2===i&&(o="z");const n=this.axisList;t.lowerBound[o],t.upperBound[o];for(let e=0;e<n.length;e++){const i=n[e];i.aabbNeedsUpdate&&i.updateAABB(),i.aabb.overlaps(t)&&s.push(i)}return s}}class Utils{static defaults(e,t){void 0===e&&(e={});for(let s in t)s in e||(e[s]=t[s]);return e}}class Constraint{constructor(e,t,s){void 0===s&&(s={}),s=Utils.defaults(s,{collideConnected:!0,wakeUpBodies:!0}),this.equations=[],this.bodyA=e,this.bodyB=t,this.id=Constraint.idCounter++,this.collideConnected=s.collideConnected,s.wakeUpBodies&&(e&&e.wakeUp(),t&&t.wakeUp())}update(){throw new Error("method update() not implmemented in this Constraint subclass!")}enable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!0}disable(){const e=this.equations;for(let t=0;t<e.length;t++)e[t].enabled=!1}}Constraint.idCounter=0;class JacobianElement{constructor(){this.spatial=new Vec3,this.rotational=new Vec3}multiplyElement(e){return e.spatial.dot(this.spatial)+e.rotational.dot(this.rotational)}multiplyVectors(e,t){return e.dot(this.spatial)+t.dot(this.rotational)}}class Equation{constructor(e,t,s,i){void 0===s&&(s=-1e6),void 0===i&&(i=1e6),this.id=Equation.idCounter++,this.minForce=s,this.maxForce=i,this.bi=e,this.bj=t,this.a=0,this.b=0,this.eps=0,this.jacobianElementA=new JacobianElement,this.jacobianElementB=new JacobianElement,this.enabled=!0,this.multiplier=0,this.setSpookParams(1e7,4,1/60)}setSpookParams(e,t,s){const i=t,o=e,n=s;this.a=4/(n*(1+4*i)),this.b=4*i/(1+4*i),this.eps=4/(n*n*o*(1+4*i))}computeB(e,t,s){const i=this.computeGW();return-this.computeGq()*e-i*t-this.computeGiMf()*s}computeGq(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,o=s.position,n=i.position;return e.spatial.dot(o)+t.spatial.dot(n)}computeGW(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,o=s.velocity,n=i.velocity,r=s.angularVelocity,l=i.angularVelocity;return e.multiplyVectors(o,r)+t.multiplyVectors(n,l)}computeGWlambda(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,o=s.vlambda,n=i.vlambda,r=s.wlambda,l=i.wlambda;return e.multiplyVectors(o,r)+t.multiplyVectors(n,l)}computeGiMf(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,o=s.force,n=s.torque,r=i.force,l=i.torque,h=s.invMassSolve,d=i.invMassSolve;return o.scale(h,iMfi),r.scale(d,iMfj),s.invInertiaWorldSolve.vmult(n,invIi_vmult_taui),i.invInertiaWorldSolve.vmult(l,invIj_vmult_tauj),e.multiplyVectors(iMfi,invIi_vmult_taui)+t.multiplyVectors(iMfj,invIj_vmult_tauj)}computeGiMGt(){const e=this.jacobianElementA,t=this.jacobianElementB,s=this.bi,i=this.bj,o=s.invMassSolve,n=i.invMassSolve,r=s.invInertiaWorldSolve,l=i.invInertiaWorldSolve;let h=o+n;return r.vmult(e.rotational,tmp),h+=tmp.dot(e.rotational),l.vmult(t.rotational,tmp),h+=tmp.dot(t.rotational),h}addToWlambda(e){const t=this.jacobianElementA,s=this.jacobianElementB,i=this.bi,o=this.bj,n=addToWlambda_temp;i.vlambda.addScaledVector(i.invMassSolve*e,t.spatial,i.vlambda),o.vlambda.addScaledVector(o.invMassSolve*e,s.spatial,o.vlambda),i.invInertiaWorldSolve.vmult(t.rotational,n),i.wlambda.addScaledVector(e,n,i.wlambda),o.invInertiaWorldSolve.vmult(s.rotational,n),o.wlambda.addScaledVector(e,n,o.wlambda)}computeC(){return this.computeGiMGt()+this.eps}}Equation.idCounter=0;const iMfi=new Vec3,iMfj=new Vec3,invIi_vmult_taui=new Vec3,invIj_vmult_tauj=new Vec3,tmp=new Vec3,addToWlambda_temp=new Vec3;class ContactEquation extends Equation{constructor(e,t,s){void 0===s&&(s=1e6),super(e,t,0,s),this.restitution=0,this.ri=new Vec3,this.rj=new Vec3,this.ni=new Vec3}computeB(e){const t=this.a,s=this.b,i=this.bi,o=this.bj,n=this.ri,r=this.rj,l=ContactEquation_computeB_temp1,h=ContactEquation_computeB_temp2,d=i.velocity,p=i.angularVelocity;i.force,i.torque;const u=o.velocity,m=o.angularVelocity;o.force,o.torque;const v=ContactEquation_computeB_temp3,y=this.jacobianElementA,g=this.jacobianElementB,x=this.ni;n.cross(x,l),r.cross(x,h),x.negate(y.spatial),l.negate(y.rotational),g.spatial.copy(x),g.rotational.copy(h),v.copy(o.position),v.vadd(r,v),v.vsub(i.position,v),v.vsub(n,v);const f=x.dot(v),w=this.restitution+1;return-f*t-(w*u.dot(x)-w*d.dot(x)+m.dot(h)-p.dot(l))*s-e*this.computeGiMf()}getImpactVelocityAlongNormal(){const e=ContactEquation_getImpactVelocityAlongNormal_vi,t=ContactEquation_getImpactVelocityAlongNormal_vj,s=ContactEquation_getImpactVelocityAlongNormal_xi,i=ContactEquation_getImpactVelocityAlongNormal_xj,o=ContactEquation_getImpactVelocityAlongNormal_relVel;return this.bi.position.vadd(this.ri,s),this.bj.position.vadd(this.rj,i),this.bi.getVelocityAtWorldPoint(s,e),this.bj.getVelocityAtWorldPoint(i,t),e.vsub(t,o),this.ni.dot(o)}}const ContactEquation_computeB_temp1=new Vec3,ContactEquation_computeB_temp2=new Vec3,ContactEquation_computeB_temp3=new Vec3,ContactEquation_getImpactVelocityAlongNormal_vi=new Vec3,ContactEquation_getImpactVelocityAlongNormal_vj=new Vec3,ContactEquation_getImpactVelocityAlongNormal_xi=new Vec3,ContactEquation_getImpactVelocityAlongNormal_xj=new Vec3,ContactEquation_getImpactVelocityAlongNormal_relVel=new Vec3;class PointToPointConstraint extends Constraint{constructor(e,t,s,i,o){void 0===t&&(t=new Vec3),void 0===i&&(i=new Vec3),void 0===o&&(o=1e6),super(e,s),this.pivotA=t.clone(),this.pivotB=i.clone();const n=this.equationX=new ContactEquation(e,s),r=this.equationY=new ContactEquation(e,s),l=this.equationZ=new ContactEquation(e,s);this.equations.push(n,r,l),n.minForce=r.minForce=l.minForce=-o,n.maxForce=r.maxForce=l.maxForce=o,n.ni.set(1,0,0),r.ni.set(0,1,0),l.ni.set(0,0,1)}update(){const e=this.bodyA,t=this.bodyB,s=this.equationX,i=this.equationY,o=this.equationZ;e.quaternion.vmult(this.pivotA,s.ri),t.quaternion.vmult(this.pivotB,s.rj),i.ri.copy(s.ri),i.rj.copy(s.rj),o.ri.copy(s.ri),o.rj.copy(s.rj)}}class ConeEquation extends Equation{constructor(e,t,s){void 0===s&&(s={});const i=void 0!==s.maxForce?s.maxForce:1e6;super(e,t,-i,i),this.axisA=s.axisA?s.axisA.clone():new Vec3(1,0,0),this.axisB=s.axisB?s.axisB.clone():new Vec3(0,1,0),this.angle=void 0!==s.angle?s.angle:0}computeB(e){const t=this.a,s=this.b,i=this.axisA,o=this.axisB,n=tmpVec1$2,r=tmpVec2$2,l=this.jacobianElementA,h=this.jacobianElementB;i.cross(o,n),o.cross(i,r),l.rotational.copy(r),h.rotational.copy(n);return-(Math.cos(this.angle)-i.dot(o))*t-this.computeGW()*s-e*this.computeGiMf()}}const tmpVec1$2=new Vec3,tmpVec2$2=new Vec3;class RotationalEquation extends Equation{constructor(e,t,s){void 0===s&&(s={});const i=void 0!==s.maxForce?s.maxForce:1e6;super(e,t,-i,i),this.axisA=s.axisA?s.axisA.clone():new Vec3(1,0,0),this.axisB=s.axisB?s.axisB.clone():new Vec3(0,1,0),this.maxAngle=Math.PI/2}computeB(e){const t=this.a,s=this.b,i=this.axisA,o=this.axisB,n=tmpVec1$1,r=tmpVec2$1,l=this.jacobianElementA,h=this.jacobianElementB;i.cross(o,n),o.cross(i,r),l.rotational.copy(r),h.rotational.copy(n);return-(Math.cos(this.maxAngle)-i.dot(o))*t-this.computeGW()*s-e*this.computeGiMf()}}const tmpVec1$1=new Vec3,tmpVec2$1=new Vec3;class ConeTwistConstraint extends PointToPointConstraint{constructor(e,t,s){void 0===s&&(s={});const i=void 0!==s.maxForce?s.maxForce:1e6;super(e,s.pivotA?s.pivotA.clone():new Vec3,t,s.pivotB?s.pivotB.clone():new Vec3,i),this.axisA=s.axisA?s.axisA.clone():new Vec3,this.axisB=s.axisB?s.axisB.clone():new Vec3,this.collideConnected=!!s.collideConnected,this.angle=void 0!==s.angle?s.angle:0;const o=this.coneEquation=new ConeEquation(e,t,s),n=this.twistEquation=new RotationalEquation(e,t,s);this.twistAngle=void 0!==s.twistAngle?s.twistAngle:0,o.maxForce=0,o.minForce=-i,n.maxForce=0,n.minForce=-i,this.equations.push(o,n)}update(){const e=this.bodyA,t=this.bodyB,s=this.coneEquation,i=this.twistEquation;super.update(),e.vectorToWorldFrame(this.axisA,s.axisA),t.vectorToWorldFrame(this.axisB,s.axisB),this.axisA.tangents(i.axisA,i.axisA),e.vectorToWorldFrame(i.axisA,i.axisA),this.axisB.tangents(i.axisB,i.axisB),t.vectorToWorldFrame(i.axisB,i.axisB),s.angle=this.angle,i.maxAngle=this.twistAngle}}new Vec3,new Vec3;class DistanceConstraint extends Constraint{constructor(e,t,s,i){void 0===i&&(i=1e6),super(e,t),void 0===s&&(s=e.position.distanceTo(t.position)),this.distance=s;const o=this.distanceEquation=new ContactEquation(e,t);this.equations.push(o),o.minForce=-i,o.maxForce=i}update(){const e=this.bodyA,t=this.bodyB,s=this.distanceEquation,i=.5*this.distance,o=s.ni;t.position.vsub(e.position,o),o.normalize(),o.scale(i,s.ri),o.scale(-i,s.rj)}}class LockConstraint extends PointToPointConstraint{constructor(e,t,s){void 0===s&&(s={});const i=void 0!==s.maxForce?s.maxForce:1e6,o=new Vec3,n=new Vec3,r=new Vec3;e.position.vadd(t.position,r),r.scale(.5,r),t.pointToLocalFrame(r,n),e.pointToLocalFrame(r,o),super(e,o,t,n,i),this.xA=e.vectorToLocalFrame(Vec3.UNIT_X),this.xB=t.vectorToLocalFrame(Vec3.UNIT_X),this.yA=e.vectorToLocalFrame(Vec3.UNIT_Y),this.yB=t.vectorToLocalFrame(Vec3.UNIT_Y),this.zA=e.vectorToLocalFrame(Vec3.UNIT_Z),this.zB=t.vectorToLocalFrame(Vec3.UNIT_Z);const l=this.rotationalEquation1=new RotationalEquation(e,t,s),h=this.rotationalEquation2=new RotationalEquation(e,t,s),d=this.rotationalEquation3=new RotationalEquation(e,t,s);this.equations.push(l,h,d)}update(){const e=this.bodyA,t=this.bodyB;this.motorEquation;const s=this.rotationalEquation1,i=this.rotationalEquation2,o=this.rotationalEquation3;super.update(),e.vectorToWorldFrame(this.xA,s.axisA),t.vectorToWorldFrame(this.yB,s.axisB),e.vectorToWorldFrame(this.yA,i.axisA),t.vectorToWorldFrame(this.zB,i.axisB),e.vectorToWorldFrame(this.zA,o.axisA),t.vectorToWorldFrame(this.xB,o.axisB)}}const LockConstraint_update_tmpVec1=new Vec3,LockConstraint_update_tmpVec2=new Vec3;class RotationalMotorEquation extends Equation{constructor(e,t,s){void 0===s&&(s=1e6),super(e,t,-s,s),this.axisA=new Vec3,this.axisB=new Vec3,this.targetVelocity=0}computeB(e){this.a;const t=this.b;this.bi,this.bj;const s=this.axisA,i=this.axisB,o=this.jacobianElementA,n=this.jacobianElementB;o.rotational.copy(s),i.negate(n.rotational);return-(this.computeGW()-this.targetVelocity)*t-e*this.computeGiMf()}}class HingeConstraint extends PointToPointConstraint{constructor(e,t,s){void 0===s&&(s={});const i=void 0!==s.maxForce?s.maxForce:1e6;super(e,s.pivotA?s.pivotA.clone():new Vec3,t,s.pivotB?s.pivotB.clone():new Vec3,i);(this.axisA=s.axisA?s.axisA.clone():new Vec3(1,0,0)).normalize();(this.axisB=s.axisB?s.axisB.clone():new Vec3(1,0,0)).normalize(),this.collideConnected=!!s.collideConnected;const o=this.rotationalEquation1=new RotationalEquation(e,t,s),n=this.rotationalEquation2=new RotationalEquation(e,t,s),r=this.motorEquation=new RotationalMotorEquation(e,t,i);r.enabled=!1,this.equations.push(o,n,r)}enableMotor(){this.motorEquation.enabled=!0}disableMotor(){this.motorEquation.enabled=!1}setMotorSpeed(e){this.motorEquation.targetVelocity=e}setMotorMaxForce(e){this.motorEquation.maxForce=e,this.motorEquation.minForce=-e}update(){const e=this.bodyA,t=this.bodyB,s=this.motorEquation,i=this.rotationalEquation1,o=this.rotationalEquation2,n=HingeConstraint_update_tmpVec1,r=HingeConstraint_update_tmpVec2,l=this.axisA,h=this.axisB;super.update(),e.quaternion.vmult(l,n),t.quaternion.vmult(h,r),n.tangents(i.axisA,o.axisA),i.axisB.copy(r),o.axisB.copy(r),this.motorEquation.enabled&&(e.quaternion.vmult(this.axisA,s.axisA),t.quaternion.vmult(this.axisB,s.axisB))}}const HingeConstraint_update_tmpVec1=new Vec3,HingeConstraint_update_tmpVec2=new Vec3;class FrictionEquation extends Equation{constructor(e,t,s){super(e,t,-s,s),this.ri=new Vec3,this.rj=new Vec3,this.t=new Vec3}computeB(e){this.a;const t=this.b;this.bi,this.bj;const s=this.ri,i=this.rj,o=FrictionEquation_computeB_temp1,n=FrictionEquation_computeB_temp2,r=this.t;s.cross(r,o),i.cross(r,n);const l=this.jacobianElementA,h=this.jacobianElementB;r.negate(l.spatial),o.negate(l.rotational),h.spatial.copy(r),h.rotational.copy(n);return-this.computeGW()*t-e*this.computeGiMf()}}const FrictionEquation_computeB_temp1=new Vec3,FrictionEquation_computeB_temp2=new Vec3;class ContactMaterial{constructor(e,t,s){s=Utils.defaults(s,{friction:.3,restitution:.3,contactEquationStiffness:1e7,contactEquationRelaxation:3,frictionEquationStiffness:1e7,frictionEquationRelaxation:3}),this.id=ContactMaterial.idCounter++,this.materials=[e,t],this.friction=s.friction,this.restitution=s.restitution,this.contactEquationStiffness=s.contactEquationStiffness,this.contactEquationRelaxation=s.contactEquationRelaxation,this.frictionEquationStiffness=s.frictionEquationStiffness,this.frictionEquationRelaxation=s.frictionEquationRelaxation}}ContactMaterial.idCounter=0;class Material{constructor(e){void 0===e&&(e={});let t="";"string"==typeof e&&(t=e,e={}),this.name=t,this.id=Material.idCounter++,this.friction=void 0!==e.friction?e.friction:-1,this.restitution=void 0!==e.restitution?e.restitution:-1}}Material.idCounter=0;class Spring{constructor(e,t,s){void 0===s&&(s={}),this.restLength="number"==typeof s.restLength?s.restLength:1,this.stiffness=s.stiffness||100,this.damping=s.damping||1,this.bodyA=e,this.bodyB=t,this.localAnchorA=new Vec3,this.localAnchorB=new Vec3,s.localAnchorA&&this.localAnchorA.copy(s.localAnchorA),s.localAnchorB&&this.localAnchorB.copy(s.localAnchorB),s.worldAnchorA&&this.setWorldAnchorA(s.worldAnchorA),s.worldAnchorB&&this.setWorldAnchorB(s.worldAnchorB)}setWorldAnchorA(e){this.bodyA.pointToLocalFrame(e,this.localAnchorA)}setWorldAnchorB(e){this.bodyB.pointToLocalFrame(e,this.localAnchorB)}getWorldAnchorA(e){this.bodyA.pointToWorldFrame(this.localAnchorA,e)}getWorldAnchorB(e){this.bodyB.pointToWorldFrame(this.localAnchorB,e)}applyForce(){const e=this.stiffness,t=this.damping,s=this.restLength,i=this.bodyA,o=this.bodyB,n=applyForce_r,r=applyForce_r_unit,l=applyForce_u,h=applyForce_f,d=applyForce_tmp,p=applyForce_worldAnchorA,u=applyForce_worldAnchorB,m=applyForce_ri,v=applyForce_rj,y=applyForce_ri_x_f,g=applyForce_rj_x_f;this.getWorldAnchorA(p),this.getWorldAnchorB(u),p.vsub(i.position,m),u.vsub(o.position,v),u.vsub(p,n);const x=n.length();r.copy(n),r.normalize(),o.velocity.vsub(i.velocity,l),o.angularVelocity.cross(v,d),l.vadd(d,l),i.angularVelocity.cross(m,d),l.vsub(d,l),r.scale(-e*(x-s)-t*l.dot(r),h),i.force.vsub(h,i.force),o.force.vadd(h,o.force),m.cross(h,y),v.cross(h,g),i.torque.vsub(y,i.torque),o.torque.vadd(g,o.torque)}}const applyForce_r=new Vec3,applyForce_r_unit=new Vec3,applyForce_u=new Vec3,applyForce_f=new Vec3,applyForce_worldAnchorA=new Vec3,applyForce_worldAnchorB=new Vec3,applyForce_ri=new Vec3,applyForce_rj=new Vec3,applyForce_ri_x_f=new Vec3,applyForce_rj_x_f=new Vec3,applyForce_tmp=new Vec3;class WheelInfo{constructor(e){void 0===e&&(e={}),e=Utils.defaults(e,{chassisConnectionPointLocal:new Vec3,chassisConnectionPointWorld:new Vec3,directionLocal:new Vec3,directionWorld:new Vec3,axleLocal:new Vec3,axleWorld:new Vec3,suspensionRestLength:1,suspensionMaxLength:2,radius:1,suspensionStiffness:100,dampingCompression:10,dampingRelaxation:10,frictionSlip:10.5,forwardAcceleration:1,sideAcceleration:1,steering:0,rotation:0,deltaRotation:0,rollInfluence:.01,maxSuspensionForce:Number.MAX_VALUE,isFrontWheel:!0,clippedInvContactDotSuspension:1,suspensionRelativeVelocity:0,suspensionForce:0,slipInfo:0,skidInfo:0,suspensionLength:0,maxSuspensionTravel:1,useCustomSlidingRotationalSpeed:!1,customSlidingRotationalSpeed:-.1}),this.maxSuspensionTravel=e.maxSuspensionTravel,this.customSlidingRotationalSpeed=e.customSlidingRotationalSpeed,this.useCustomSlidingRotationalSpeed=e.useCustomSlidingRotationalSpeed,this.sliding=!1,this.chassisConnectionPointLocal=e.chassisConnectionPointLocal.clone(),this.chassisConnectionPointWorld=e.chassisConnectionPointWorld.clone(),this.directionLocal=e.directionLocal.clone(),this.directionWorld=e.directionWorld.clone(),this.axleLocal=e.axleLocal.clone(),this.axleWorld=e.axleWorld.clone(),this.suspensionRestLength=e.suspensionRestLength,this.suspensionMaxLength=e.suspensionMaxLength,this.radius=e.radius,this.suspensionStiffness=e.suspensionStiffness,this.dampingCompression=e.dampingCompression,this.dampingRelaxation=e.dampingRelaxation,this.frictionSlip=e.frictionSlip,this.forwardAcceleration=e.forwardAcceleration,this.sideAcceleration=e.sideAcceleration,this.steering=0,this.rotation=0,this.deltaRotation=0,this.rollInfluence=e.rollInfluence,this.maxSuspensionForce=e.maxSuspensionForce,this.engineForce=0,this.brake=0,this.isFrontWheel=e.isFrontWheel,this.clippedInvContactDotSuspension=1,this.suspensionRelativeVelocity=0,this.suspensionForce=0,this.slipInfo=0,this.skidInfo=0,this.suspensionLength=0,this.sideImpulse=0,this.forwardImpulse=0,this.raycastResult=new RaycastResult,this.worldTransform=new Transform,this.isInContact=!1}updateWheel(e){const t=this.raycastResult;if(this.isInContact){const s=t.hitNormalWorld.dot(t.directionWorld);t.hitPointWorld.vsub(e.position,relpos),e.getVelocityAtWorldPoint(relpos,chassis_velocity_at_contactPoint);const i=t.hitNormalWorld.dot(chassis_velocity_at_contactPoint);if(s>=-.1)this.suspensionRelativeVelocity=0,this.clippedInvContactDotSuspension=10;else{const e=-1/s;this.suspensionRelativeVelocity=i*e,this.clippedInvContactDotSuspension=e}}else t.suspensionLength=this.suspensionRestLength,this.suspensionRelativeVelocity=0,t.directionWorld.scale(-1,t.hitNormalWorld),this.clippedInvContactDotSuspension=1}}const chassis_velocity_at_contactPoint=new Vec3,relpos=new Vec3;class RaycastVehicle{constructor(e){this.chassisBody=e.chassisBody,this.wheelInfos=[],this.sliding=!1,this.world=null,this.indexRightAxis=void 0!==e.indexRightAxis?e.indexRightAxis:2,this.indexForwardAxis=void 0!==e.indexForwardAxis?e.indexForwardAxis:0,this.indexUpAxis=void 0!==e.indexUpAxis?e.indexUpAxis:1,this.constraints=[],this.preStepCallback=()=>{},this.currentVehicleSpeedKmHour=0,this.numWheelsOnGround=0}addWheel(e){void 0===e&&(e={});const t=new WheelInfo(e),s=this.wheelInfos.length;return this.wheelInfos.push(t),s}setSteeringValue(e,t){this.wheelInfos[t].steering=e}applyEngineForce(e,t){this.wheelInfos[t].engineForce=e}setBrake(e,t){this.wheelInfos[t].brake=e}addToWorld(e){e.addBody(this.chassisBody);const t=this;this.preStepCallback=()=>{t.updateVehicle(e.dt)},e.addEventListener("preStep",this.preStepCallback),this.world=e}getVehicleAxisWorld(e,t){t.set(0===e?1:0,1===e?1:0,2===e?1:0),this.chassisBody.vectorToWorldFrame(t,t)}updateVehicle(e){const t=this.wheelInfos,s=t.length,i=this.chassisBody;for(let e=0;e<s;e++)this.updateWheelTransform(e);this.currentVehicleSpeedKmHour=3.6*i.velocity.length();const o=new Vec3;this.getVehicleAxisWorld(this.indexForwardAxis,o),o.dot(i.velocity)<0&&(this.currentVehicleSpeedKmHour*=-1);for(let e=0;e<s;e++)this.castRay(t[e]);this.updateSuspension(e);const n=new Vec3,r=new Vec3;for(let o=0;o<s;o++){const s=t[o];let l=s.suspensionForce;l>s.maxSuspensionForce&&(l=s.maxSuspensionForce),s.raycastResult.hitNormalWorld.scale(l*e,n),s.raycastResult.hitPointWorld.vsub(i.position,r),i.applyImpulse(n,r)}this.updateFriction(e);const l=new Vec3,h=new Vec3,d=new Vec3;for(let o=0;o<s;o++){const s=t[o];i.getVelocityAtWorldPoint(s.chassisConnectionPointWorld,d);let n=1;if(1===this.indexUpAxis)n=-1;if(s.isInContact){this.getVehicleAxisWorld(this.indexForwardAxis,h);const t=h.dot(s.raycastResult.hitNormalWorld);s.raycastResult.hitNormalWorld.scale(t,l),h.vsub(l,h);const i=h.dot(d);s.deltaRotation=n*i*e/s.radius}!s.sliding&&s.isInContact||0===s.engineForce||!s.useCustomSlidingRotationalSpeed||(s.deltaRotation=(s.engineForce>0?1:-1)*s.customSlidingRotationalSpeed*e),Math.abs(s.brake)>Math.abs(s.engineForce)&&(s.deltaRotation=0),s.rotation+=s.deltaRotation,s.deltaRotation*=.99}}updateSuspension(e){const t=this.chassisBody.mass,s=this.wheelInfos,i=s.length;for(let e=0;e<i;e++){const i=s[e];if(i.isInContact){let e;const s=i.suspensionRestLength-i.suspensionLength;e=i.suspensionStiffness*s*i.clippedInvContactDotSuspension;const o=i.suspensionRelativeVelocity;let n;n=o<0?i.dampingCompression:i.dampingRelaxation,e-=n*o,i.suspensionForce=e*t,i.suspensionForce<0&&(i.suspensionForce=0)}else i.suspensionForce=0}}removeFromWorld(e){this.constraints,e.removeBody(this.chassisBody),e.removeEventListener("preStep",this.preStepCallback),this.world=null}castRay(e){const t=castRay_rayvector,s=castRay_target;this.updateWheelTransformWorld(e);const i=this.chassisBody;let o=-1;const n=e.suspensionRestLength+e.radius;e.directionWorld.scale(n,t);const r=e.chassisConnectionPointWorld;r.vadd(t,s);const l=e.raycastResult;l.reset();const h=i.collisionResponse;i.collisionResponse=!1,this.world.rayTest(r,s,l),i.collisionResponse=h;const d=l.body;if(e.raycastResult.groundObject=0,d){o=l.distance,e.raycastResult.hitNormalWorld=l.hitNormalWorld,e.isInContact=!0;const t=l.distance;e.suspensionLength=t-e.radius;const s=e.suspensionRestLength-e.maxSuspensionTravel,n=e.suspensionRestLength+e.maxSuspensionTravel;e.suspensionLength<s&&(e.suspensionLength=s),e.suspensionLength>n&&(e.suspensionLength=n,e.raycastResult.reset());const r=e.raycastResult.hitNormalWorld.dot(e.directionWorld),h=new Vec3;i.getVelocityAtWorldPoint(e.raycastResult.hitPointWorld,h);const d=e.raycastResult.hitNormalWorld.dot(h);if(r>=-.1)e.suspensionRelativeVelocity=0,e.clippedInvContactDotSuspension=10;else{const t=-1/r;e.suspensionRelativeVelocity=d*t,e.clippedInvContactDotSuspension=t}}else e.suspensionLength=e.suspensionRestLength+0*e.maxSuspensionTravel,e.suspensionRelativeVelocity=0,e.directionWorld.scale(-1,e.raycastResult.hitNormalWorld),e.clippedInvContactDotSuspension=1;return o}updateWheelTransformWorld(e){e.isInContact=!1;const t=this.chassisBody;t.pointToWorldFrame(e.chassisConnectionPointLocal,e.chassisConnectionPointWorld),t.vectorToWorldFrame(e.directionLocal,e.directionWorld),t.vectorToWorldFrame(e.axleLocal,e.axleWorld)}updateWheelTransform(e){const t=tmpVec4,s=tmpVec5,i=tmpVec6,o=this.wheelInfos[e];this.updateWheelTransformWorld(o),o.directionLocal.scale(-1,t),s.copy(o.axleLocal),t.cross(s,i),i.normalize(),s.normalize();const n=o.steering,r=new Quaternion;r.setFromAxisAngle(t,n);const l=new Quaternion;l.setFromAxisAngle(s,o.rotation);const h=o.worldTransform.quaternion;this.chassisBody.quaternion.mult(r,h),h.mult(l,h),h.normalize();const d=o.worldTransform.position;d.copy(o.directionWorld),d.scale(o.suspensionLength,d),d.vadd(o.chassisConnectionPointWorld,d)}getWheelTransformWorld(e){return this.wheelInfos[e].worldTransform}updateFriction(e){const t=updateFriction_surfNormalWS_scaled_proj,s=this.wheelInfos,i=s.length,o=this.chassisBody,n=updateFriction_forwardWS,r=updateFriction_axle;this.numWheelsOnGround=0;for(let e=0;e<i;e++){const t=s[e];t.raycastResult.body&&this.numWheelsOnGround++,t.sideImpulse=0,t.forwardImpulse=0,n[e]||(n[e]=new Vec3),r[e]||(r[e]=new Vec3)}for(let e=0;e<i;e++){const i=s[e],l=i.raycastResult.body;if(l){const s=r[e];this.getWheelTransformWorld(e).vectorToWorldFrame(directions[this.indexRightAxis],s);const h=i.raycastResult.hitNormalWorld,d=s.dot(h);h.scale(d,t),s.vsub(t,s),s.normalize(),h.cross(s,n[e]),n[e].normalize(),i.sideImpulse=resolveSingleBilateral(o,i.raycastResult.hitPointWorld,l,i.raycastResult.hitPointWorld,s),i.sideImpulse*=sideFrictionStiffness2}}this.sliding=!1;for(let t=0;t<i;t++){const i=s[t],r=i.raycastResult.body;let l=0;if(i.slipInfo=1,r){const s=0,h=i.brake?i.brake:s;l=calcRollingFriction(o,r,i.raycastResult.hitPointWorld,n[t],h),l+=i.engineForce*e;const d=h/l;i.slipInfo*=d}if(i.forwardImpulse=0,i.skidInfo=1,r){i.skidInfo=1;const t=i.suspensionForce*e*i.frictionSlip,s=t*t;i.forwardImpulse=l;const o=.5*i.forwardImpulse/i.forwardAcceleration,n=1*i.sideImpulse/i.sideAcceleration,r=o*o+n*n;if(i.sliding=!1,r>s){this.sliding=!0,i.sliding=!0;const e=t/Math.sqrt(r);i.skidInfo*=e}}}if(this.sliding)for(let e=0;e<i;e++){const t=s[e];0!==t.sideImpulse&&t.skidInfo<1&&(t.forwardImpulse*=t.skidInfo,t.sideImpulse*=t.skidInfo)}for(let e=0;e<i;e++){const t=s[e],i=new Vec3;if(t.raycastResult.hitPointWorld.vsub(o.position,i),0!==t.forwardImpulse){const s=new Vec3;n[e].scale(t.forwardImpulse,s),o.applyImpulse(s,i)}if(0!==t.sideImpulse){const s=t.raycastResult.body,n=new Vec3;t.raycastResult.hitPointWorld.vsub(s.position,n);const l=new Vec3;r[e].scale(t.sideImpulse,l),o.vectorToLocalFrame(i,i),i["xyz"[this.indexUpAxis]]*=t.rollInfluence,o.vectorToWorldFrame(i,i),o.applyImpulse(l,i),l.scale(-1,l),s.applyImpulse(l,n)}}}}new Vec3,new Vec3,new Vec3;const tmpVec4=new Vec3,tmpVec5=new Vec3,tmpVec6=new Vec3;new Ray,new Vec3;const castRay_rayvector=new Vec3,castRay_target=new Vec3,directions=[new Vec3(1,0,0),new Vec3(0,1,0),new Vec3(0,0,1)],updateFriction_surfNormalWS_scaled_proj=new Vec3,updateFriction_axle=[],updateFriction_forwardWS=[],sideFrictionStiffness2=1,calcRollingFriction_vel1=new Vec3,calcRollingFriction_vel2=new Vec3,calcRollingFriction_vel=new Vec3;function calcRollingFriction(e,t,s,i,o){let n=0;const r=s,l=calcRollingFriction_vel1,h=calcRollingFriction_vel2,d=calcRollingFriction_vel;e.getVelocityAtWorldPoint(r,l),t.getVelocityAtWorldPoint(r,h),l.vsub(h,d);return n=-i.dot(d)*(1/(computeImpulseDenominator(e,s,i)+computeImpulseDenominator(t,s,i))),o<n&&(n=o),n<-o&&(n=-o),n}const computeImpulseDenominator_r0=new Vec3,computeImpulseDenominator_c0=new Vec3,computeImpulseDenominator_vec=new Vec3,computeImpulseDenominator_m=new Vec3;function computeImpulseDenominator(e,t,s){const i=computeImpulseDenominator_r0,o=computeImpulseDenominator_c0,n=computeImpulseDenominator_vec,r=computeImpulseDenominator_m;return t.vsub(e.position,i),i.cross(s,o),e.invInertiaWorld.vmult(o,r),r.cross(i,n),e.invMass+s.dot(n)}const resolveSingleBilateral_vel1=new Vec3,resolveSingleBilateral_vel2=new Vec3,resolveSingleBilateral_vel=new Vec3;function resolveSingleBilateral(e,t,s,i,o){if(o.lengthSquared()>1.1)return 0;const n=resolveSingleBilateral_vel1,r=resolveSingleBilateral_vel2,l=resolveSingleBilateral_vel;e.getVelocityAtWorldPoint(t,n),s.getVelocityAtWorldPoint(i,r),n.vsub(r,l);return-.2*o.dot(l)*(1/(e.invMass+s.invMass))}class Sphere extends Shape{constructor(e){if(super({type:Shape.types.SPHERE}),this.radius=void 0!==e?e:1,this.radius<0)throw new Error("The sphere radius cannot be negative.");this.updateBoundingSphereRadius()}calculateLocalInertia(e,t){void 0===t&&(t=new Vec3);const s=2*e*this.radius*this.radius/5;return t.x=s,t.y=s,t.z=s,t}volume(){return 4*Math.PI*Math.pow(this.radius,3)/3}updateBoundingSphereRadius(){this.boundingSphereRadius=this.radius}calculateWorldAABB(e,t,s,i){const o=this.radius,n=["x","y","z"];for(let t=0;t<n.length;t++){const r=n[t];s[r]=e[r]-o,i[r]=e[r]+o}}}class RigidVehicle{constructor(e){void 0===e&&(e={}),this.wheelBodies=[],this.coordinateSystem=void 0!==e.coordinateSystem?e.coordinateSystem.clone():new Vec3(1,2,3),e.chassisBody?this.chassisBody=e.chassisBody:this.chassisBody=new Body({mass:1,shape:new Box(new Vec3(5,.5,2))}),this.constraints=[],this.wheelAxes=[],this.wheelForces=[]}addWheel(e){let t;void 0===e&&(e={}),t=e.body?e.body:new Body({mass:1,shape:new Sphere(1.2)}),this.wheelBodies.push(t),this.wheelForces.push(0);const s=void 0!==e.position?e.position.clone():new Vec3,i=new Vec3;this.chassisBody.pointToWorldFrame(s,i),t.position.set(i.x,i.y,i.z);const o=void 0!==e.axis?e.axis.clone():new Vec3(0,0,1);this.wheelAxes.push(o);const n=new HingeConstraint(this.chassisBody,t,{pivotA:s,axisA:o,pivotB:Vec3.ZERO,axisB:o,collideConnected:!1});return this.constraints.push(n),this.wheelBodies.length-1}setSteeringValue(e,t){const s=this.wheelAxes[t],i=Math.cos(e),o=Math.sin(e),n=s.x,r=s.z;this.constraints[t].axisA.set(-i*n+o*r,0,o*n+i*r)}setMotorSpeed(e,t){const s=this.constraints[t];s.enableMotor(),s.motorTargetVelocity=e}disableMotor(e){this.constraints[e].disableMotor()}setWheelForce(e,t){this.wheelForces[t]=e}applyWheelForce(e,t){const s=this.wheelAxes[t],i=this.wheelBodies[t],o=i.torque;s.scale(e,torque),i.vectorToWorldFrame(torque,torque),o.vadd(torque,o)}addToWorld(e){const t=this.constraints,s=this.wheelBodies.concat([this.chassisBody]);for(let t=0;t<s.length;t++)e.addBody(s[t]);for(let s=0;s<t.length;s++)e.addConstraint(t[s]);e.addEventListener("preStep",this._update.bind(this))}_update(){const e=this.wheelForces;for(let t=0;t<e.length;t++)this.applyWheelForce(e[t],t)}removeFromWorld(e){const t=this.constraints,s=this.wheelBodies.concat([this.chassisBody]);for(let t=0;t<s.length;t++)e.removeBody(s[t]);for(let s=0;s<t.length;s++)e.removeConstraint(t[s])}getWheelSpeed(e){const t=this.wheelAxes[e],s=this.wheelBodies[e].angularVelocity;return this.chassisBody.vectorToWorldFrame(t,worldAxis),s.dot(worldAxis)}}const torque=new Vec3,worldAxis=new Vec3;class SPHSystem{constructor(){this.particles=[],this.density=1,this.smoothingRadius=1,this.speedOfSound=1,this.viscosity=.01,this.eps=1e-6,this.pressures=[],this.densities=[],this.neighbors=[]}add(e){this.particles.push(e),this.neighbors.length<this.particles.length&&this.neighbors.push([])}remove(e){const t=this.particles.indexOf(e);-1!==t&&(this.particles.splice(t,1),this.neighbors.length>this.particles.length&&this.neighbors.pop())}getNeighbors(e,t){const s=this.particles.length,i=e.id,o=this.smoothingRadius*this.smoothingRadius,n=SPHSystem_getNeighbors_dist;for(let r=0;r!==s;r++){const s=this.particles[r];s.position.vsub(e.position,n),i!==s.id&&n.lengthSquared()<o&&t.push(s)}}update(){const e=this.particles.length,t=SPHSystem_update_dist,s=this.speedOfSound,i=this.eps;for(let i=0;i!==e;i++){const e=this.particles[i],o=this.neighbors[i];o.length=0,this.getNeighbors(e,o),o.push(this.particles[i]);const n=o.length;let r=0;for(let s=0;s!==n;s++){e.position.vsub(o[s].position,t);const i=t.length(),n=this.w(i);r+=o[s].mass*n}this.densities[i]=r,this.pressures[i]=s*s*(this.densities[i]-this.density)}const o=SPHSystem_update_a_pressure,n=SPHSystem_update_a_visc,r=SPHSystem_update_gradW,l=SPHSystem_update_r_vec,h=SPHSystem_update_u;for(let t=0;t!==e;t++){const e=this.particles[t];let s,d;o.set(0,0,0),n.set(0,0,0);const p=this.neighbors[t],u=p.length;for(let m=0;m!==u;m++){const u=p[m];e.position.vsub(u.position,l);const v=l.length();s=-u.mass*(this.pressures[t]/(this.densities[t]*this.densities[t]+i)+this.pressures[m]/(this.densities[m]*this.densities[m]+i)),this.gradw(l,r),r.scale(s,r),o.vadd(r,o),u.velocity.vsub(e.velocity,h),h.scale(1/(1e-4+this.densities[t]*this.densities[m])*this.viscosity*u.mass,h),d=this.nablaw(v),h.scale(d,h),n.vadd(h,n)}n.scale(e.mass,n),o.scale(e.mass,o),e.force.vadd(n,e.force),e.force.vadd(o,e.force)}}w(e){const t=this.smoothingRadius;return 315/(64*Math.PI*t**9)*(t*t-e*e)**3}gradw(e,t){const s=e.length(),i=this.smoothingRadius;e.scale(945/(32*Math.PI*i**9)*(i*i-s*s)**2,t)}nablaw(e){const t=this.smoothingRadius;return 945/(32*Math.PI*t**9)*(t*t-e*e)*(7*e*e-3*t*t)}}const SPHSystem_getNeighbors_dist=new Vec3,SPHSystem_update_dist=new Vec3,SPHSystem_update_a_pressure=new Vec3,SPHSystem_update_a_visc=new Vec3,SPHSystem_update_gradW=new Vec3,SPHSystem_update_r_vec=new Vec3,SPHSystem_update_u=new Vec3;class Cylinder extends ConvexPolyhedron{constructor(e,t,s,i){if(void 0===e&&(e=1),void 0===t&&(t=1),void 0===s&&(s=1),void 0===i&&(i=8),e<0)throw new Error("The cylinder radiusTop cannot be negative.");if(t<0)throw new Error("The cylinder radiusBottom cannot be negative.");const o=i,n=[],r=[],l=[],h=[],d=[],p=Math.cos,u=Math.sin;n.push(new Vec3(-t*u(0),.5*-s,t*p(0))),h.push(0),n.push(new Vec3(-e*u(0),.5*s,e*p(0))),d.push(1);for(let i=0;i<o;i++){const m=2*Math.PI/o*(i+1),v=2*Math.PI/o*(i+.5);i<o-1?(n.push(new Vec3(-t*u(m),.5*-s,t*p(m))),h.push(2*i+2),n.push(new Vec3(-e*u(m),.5*s,e*p(m))),d.push(2*i+3),l.push([2*i,2*i+1,2*i+3,2*i+2])):l.push([2*i,2*i+1,1,0]),(o%2==1||i<o/2)&&r.push(new Vec3(-u(v),0,p(v)))}l.push(h),r.push(new Vec3(0,1,0));const m=[];for(let e=0;e<d.length;e++)m.push(d[d.length-e-1]);l.push(m),super({vertices:n,faces:l,axes:r}),this.type=Shape.types.CYLINDER,this.radiusTop=e,this.radiusBottom=t,this.height=s,this.numSegments=i}}class Particle extends Shape{constructor(){super({type:Shape.types.PARTICLE})}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),t.set(0,0,0),t}volume(){return 0}updateBoundingSphereRadius(){this.boundingSphereRadius=0}calculateWorldAABB(e,t,s,i){s.copy(e),i.copy(e)}}class Plane extends Shape{constructor(){super({type:Shape.types.PLANE}),this.worldNormal=new Vec3,this.worldNormalNeedsUpdate=!0,this.boundingSphereRadius=Number.MAX_VALUE}computeWorldNormal(e){const t=this.worldNormal;t.set(0,0,1),e.vmult(t,t),this.worldNormalNeedsUpdate=!1}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,s,i){tempNormal.set(0,0,1),t.vmult(tempNormal,tempNormal);const o=Number.MAX_VALUE;s.set(-o,-o,-o),i.set(o,o,o),1===tempNormal.x?i.x=e.x:-1===tempNormal.x&&(s.x=e.x),1===tempNormal.y?i.y=e.y:-1===tempNormal.y&&(s.y=e.y),1===tempNormal.z?i.z=e.z:-1===tempNormal.z&&(s.z=e.z)}updateBoundingSphereRadius(){this.boundingSphereRadius=Number.MAX_VALUE}}const tempNormal=new Vec3;class Heightfield extends Shape{constructor(e,t){void 0===t&&(t={}),t=Utils.defaults(t,{maxValue:null,minValue:null,elementSize:1}),super({type:Shape.types.HEIGHTFIELD}),this.data=e,this.maxValue=t.maxValue,this.minValue=t.minValue,this.elementSize=t.elementSize,null===t.minValue&&this.updateMinValue(),null===t.maxValue&&this.updateMaxValue(),this.cacheEnabled=!0,this.pillarConvex=new ConvexPolyhedron,this.pillarOffset=new Vec3,this.updateBoundingSphereRadius(),this._cachedPillars={}}update(){this._cachedPillars={}}updateMinValue(){const e=this.data;let t=e[0][0];for(let s=0;s!==e.length;s++)for(let i=0;i!==e[s].length;i++){const o=e[s][i];o<t&&(t=o)}this.minValue=t}updateMaxValue(){const e=this.data;let t=e[0][0];for(let s=0;s!==e.length;s++)for(let i=0;i!==e[s].length;i++){const o=e[s][i];o>t&&(t=o)}this.maxValue=t}setHeightValueAtIndex(e,t,s){this.data[e][t]=s,this.clearCachedConvexTrianglePillar(e,t,!1),e>0&&(this.clearCachedConvexTrianglePillar(e-1,t,!0),this.clearCachedConvexTrianglePillar(e-1,t,!1)),t>0&&(this.clearCachedConvexTrianglePillar(e,t-1,!0),this.clearCachedConvexTrianglePillar(e,t-1,!1)),t>0&&e>0&&this.clearCachedConvexTrianglePillar(e-1,t-1,!0)}getRectMinMax(e,t,s,i,o){void 0===o&&(o=[]);const n=this.data;let r=this.minValue;for(let o=e;o<=s;o++)for(let e=t;e<=i;e++){const t=n[o][e];t>r&&(r=t)}o[0]=this.minValue,o[1]=r}getIndexOfPosition(e,t,s,i){const o=this.elementSize,n=this.data;let r=Math.floor(e/o),l=Math.floor(t/o);return s[0]=r,s[1]=l,i&&(r<0&&(r=0),l<0&&(l=0),r>=n.length-1&&(r=n.length-1),l>=n[0].length-1&&(l=n[0].length-1)),!(r<0||l<0||r>=n.length-1||l>=n[0].length-1)}getTriangleAt(e,t,s,i,o,n){const r=getHeightAt_idx;this.getIndexOfPosition(e,t,r,s);let l=r[0],h=r[1];const d=this.data;s&&(l=Math.min(d.length-2,Math.max(0,l)),h=Math.min(d[0].length-2,Math.max(0,h)));const p=this.elementSize,u=(e/p-l)**2+(t/p-h)**2>(e/p-(l+1))**2+(t/p-(h+1))**2;return this.getTriangle(l,h,u,i,o,n),u}getNormalAt(e,t,s,i){const o=getNormalAt_a,n=getNormalAt_b,r=getNormalAt_c,l=getNormalAt_e0,h=getNormalAt_e1;this.getTriangleAt(e,t,s,o,n,r),n.vsub(o,l),r.vsub(o,h),l.cross(h,i),i.normalize()}getAabbAtIndex(e,t,s){let{lowerBound:i,upperBound:o}=s;const n=this.data,r=this.elementSize;i.set(e*r,t*r,n[e][t]),o.set((e+1)*r,(t+1)*r,n[e+1][t+1])}getHeightAt(e,t,s){const i=this.data,o=getHeightAt_a,n=getHeightAt_b,r=getHeightAt_c,l=getHeightAt_idx;this.getIndexOfPosition(e,t,l,s);let h=l[0],d=l[1];s&&(h=Math.min(i.length-2,Math.max(0,h)),d=Math.min(i[0].length-2,Math.max(0,d)));const p=this.getTriangleAt(e,t,s,o,n,r);barycentricWeights(e,t,o.x,o.y,n.x,n.y,r.x,r.y,getHeightAt_weights);const u=getHeightAt_weights;return p?i[h+1][d+1]*u.x+i[h][d+1]*u.y+i[h+1][d]*u.z:i[h][d]*u.x+i[h+1][d]*u.y+i[h][d+1]*u.z}getCacheConvexTrianglePillarKey(e,t,s){return`${e}_${t}_${s?1:0}`}getCachedConvexTrianglePillar(e,t,s){return this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,s)]}setCachedConvexTrianglePillar(e,t,s,i,o){this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,s)]={convex:i,offset:o}}clearCachedConvexTrianglePillar(e,t,s){delete this._cachedPillars[this.getCacheConvexTrianglePillarKey(e,t,s)]}getTriangle(e,t,s,i,o,n){const r=this.data,l=this.elementSize;s?(i.set((e+1)*l,(t+1)*l,r[e+1][t+1]),o.set(e*l,(t+1)*l,r[e][t+1]),n.set((e+1)*l,t*l,r[e+1][t])):(i.set(e*l,t*l,r[e][t]),o.set((e+1)*l,t*l,r[e+1][t]),n.set(e*l,(t+1)*l,r[e][t+1]))}getConvexTrianglePillar(e,t,s){let i=this.pillarConvex,o=this.pillarOffset;if(this.cacheEnabled){const n=this.getCachedConvexTrianglePillar(e,t,s);if(n)return this.pillarConvex=n.convex,void(this.pillarOffset=n.offset);i=new ConvexPolyhedron,o=new Vec3,this.pillarConvex=i,this.pillarOffset=o}const n=this.data,r=this.elementSize,l=i.faces;i.vertices.length=6;for(let e=0;e<6;e++)i.vertices[e]||(i.vertices[e]=new Vec3);l.length=5;for(let e=0;e<5;e++)l[e]||(l[e]=[]);const h=i.vertices,d=(Math.min(n[e][t],n[e+1][t],n[e][t+1],n[e+1][t+1])-this.minValue)/2+this.minValue;s?(o.set((e+.75)*r,(t+.75)*r,d),h[0].set(.25*r,.25*r,n[e+1][t+1]-d),h[1].set(-.75*r,.25*r,n[e][t+1]-d),h[2].set(.25*r,-.75*r,n[e+1][t]-d),h[3].set(.25*r,.25*r,-Math.abs(d)-1),h[4].set(-.75*r,.25*r,-Math.abs(d)-1),h[5].set(.25*r,-.75*r,-Math.abs(d)-1),l[0][0]=0,l[0][1]=1,l[0][2]=2,l[1][0]=5,l[1][1]=4,l[1][2]=3,l[2][0]=2,l[2][1]=5,l[2][2]=3,l[2][3]=0,l[3][0]=3,l[3][1]=4,l[3][2]=1,l[3][3]=0,l[4][0]=1,l[4][1]=4,l[4][2]=5,l[4][3]=2):(o.set((e+.25)*r,(t+.25)*r,d),h[0].set(-.25*r,-.25*r,n[e][t]-d),h[1].set(.75*r,-.25*r,n[e+1][t]-d),h[2].set(-.25*r,.75*r,n[e][t+1]-d),h[3].set(-.25*r,-.25*r,-Math.abs(d)-1),h[4].set(.75*r,-.25*r,-Math.abs(d)-1),h[5].set(-.25*r,.75*r,-Math.abs(d)-1),l[0][0]=0,l[0][1]=1,l[0][2]=2,l[1][0]=5,l[1][1]=4,l[1][2]=3,l[2][0]=0,l[2][1]=2,l[2][2]=5,l[2][3]=3,l[3][0]=1,l[3][1]=0,l[3][2]=3,l[3][3]=4,l[4][0]=4,l[4][1]=5,l[4][2]=2,l[4][3]=1),i.computeNormals(),i.computeEdges(),i.updateBoundingSphereRadius(),this.setCachedConvexTrianglePillar(e,t,s,i,o)}calculateLocalInertia(e,t){return void 0===t&&(t=new Vec3),t.set(0,0,0),t}volume(){return Number.MAX_VALUE}calculateWorldAABB(e,t,s,i){s.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),i.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)}updateBoundingSphereRadius(){const e=this.data,t=this.elementSize;this.boundingSphereRadius=new Vec3(e.length*t,e[0].length*t,Math.max(Math.abs(this.maxValue),Math.abs(this.minValue))).length()}setHeightsFromImage(e,t){const{x:s,z:i,y:o}=t,n=document.createElement("canvas");n.width=e.width,n.height=e.height;const r=n.getContext("2d");r.drawImage(e,0,0);const l=r.getImageData(0,0,e.width,e.height),h=this.data;h.length=0,this.elementSize=Math.abs(s)/l.width;for(let e=0;e<l.height;e++){const t=[];for(let o=0;o<l.width;o++){const n=(l.data[4*(e*l.height+o)]+l.data[4*(e*l.height+o)+1]+l.data[4*(e*l.height+o)+2])/4/255*i;s<0?t.push(n):t.unshift(n)}o<0?h.unshift(t):h.push(t)}this.updateMaxValue(),this.updateMinValue(),this.update()}}const getHeightAt_idx=[],getHeightAt_weights=new Vec3,getHeightAt_a=new Vec3,getHeightAt_b=new Vec3,getHeightAt_c=new Vec3,getNormalAt_a=new Vec3,getNormalAt_b=new Vec3,getNormalAt_c=new Vec3,getNormalAt_e0=new Vec3,getNormalAt_e1=new Vec3;function barycentricWeights(e,t,s,i,o,n,r,l,h){h.x=((n-l)*(e-r)+(r-o)*(t-l))/((n-l)*(s-r)+(r-o)*(i-l)),h.y=((l-i)*(e-r)+(s-r)*(t-l))/((n-l)*(s-r)+(r-o)*(i-l)),h.z=1-h.x-h.y}class OctreeNode{constructor(e){void 0===e&&(e={}),this.root=e.root||null,this.aabb=e.aabb?e.aabb.clone():new AABB,this.data=[],this.children=[]}reset(){this.children.length=this.data.length=0}insert(e,t,s){void 0===s&&(s=0);const i=this.data;if(!this.aabb.contains(e))return!1;const o=this.children;if(s<(this.maxDepth||this.root.maxDepth)){let i=!1;o.length||(this.subdivide(),i=!0);for(let i=0;8!==i;i++)if(o[i].insert(e,t,s+1))return!0;i&&(o.length=0)}return i.push(t),!0}subdivide(){const e=this.aabb,t=e.lowerBound,s=e.upperBound,i=this.children;i.push(new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,0,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,0,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,1,0)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,1,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,1,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,0,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(1,0,1)})}),new OctreeNode({aabb:new AABB({lowerBound:new Vec3(0,1,0)})})),s.vsub(t,halfDiagonal),halfDiagonal.scale(.5,halfDiagonal);const o=this.root||this;for(let e=0;8!==e;e++){const s=i[e];s.root=o;const n=s.aabb.lowerBound;n.x*=halfDiagonal.x,n.y*=halfDiagonal.y,n.z*=halfDiagonal.z,n.vadd(t,n),n.vadd(halfDiagonal,s.aabb.upperBound)}}aabbQuery(e,t){this.data,this.children;const s=[this];for(;s.length;){const i=s.pop();i.aabb.overlaps(e)&&Array.prototype.push.apply(t,i.data),Array.prototype.push.apply(s,i.children)}return t}rayQuery(e,t,s){return e.getAABB(tmpAABB),tmpAABB.toLocalFrame(t,tmpAABB),this.aabbQuery(tmpAABB,s),s}removeEmptyNodes(){for(let e=this.children.length-1;e>=0;e--)this.children[e].removeEmptyNodes(),this.children[e].children.length||this.children[e].data.length||this.children.splice(e,1)}}class Octree extends OctreeNode{constructor(e,t){void 0===t&&(t={}),super({root:null,aabb:e}),this.maxDepth=void 0!==t.maxDepth?t.maxDepth:8}}const halfDiagonal=new Vec3,tmpAABB=new AABB;class Trimesh extends Shape{constructor(e,t){super({type:Shape.types.TRIMESH}),this.vertices=new Float32Array(e),this.indices=new Int16Array(t),this.normals=new Float32Array(t.length),this.aabb=new AABB,this.edges=null,this.scale=new Vec3(1,1,1),this.tree=new Octree,this.updateEdges(),this.updateNormals(),this.updateAABB(),this.updateBoundingSphereRadius(),this.updateTree()}updateTree(){const e=this.tree;e.reset(),e.aabb.copy(this.aabb);const t=this.scale;e.aabb.lowerBound.x*=1/t.x,e.aabb.lowerBound.y*=1/t.y,e.aabb.lowerBound.z*=1/t.z,e.aabb.upperBound.x*=1/t.x,e.aabb.upperBound.y*=1/t.y,e.aabb.upperBound.z*=1/t.z;const s=new AABB,i=new Vec3,o=new Vec3,n=new Vec3,r=[i,o,n];for(let t=0;t<this.indices.length/3;t++){const l=3*t;this._getUnscaledVertex(this.indices[l],i),this._getUnscaledVertex(this.indices[l+1],o),this._getUnscaledVertex(this.indices[l+2],n),s.setFromPoints(r),e.insert(s,t)}e.removeEmptyNodes()}getTrianglesInAABB(e,t){unscaledAABB.copy(e);const s=this.scale,i=s.x,o=s.y,n=s.z,r=unscaledAABB.lowerBound,l=unscaledAABB.upperBound;return r.x/=i,r.y/=o,r.z/=n,l.x/=i,l.y/=o,l.z/=n,this.tree.aabbQuery(unscaledAABB,t)}setScale(e){const t=this.scale.x===this.scale.y&&this.scale.y===this.scale.z,s=e.x===e.y&&e.y===e.z;t&&s||this.updateNormals(),this.scale.copy(e),this.updateAABB(),this.updateBoundingSphereRadius()}updateNormals(){const e=computeNormals_n,t=this.normals;for(let s=0;s<this.indices.length/3;s++){const i=3*s,o=this.indices[i],n=this.indices[i+1],r=this.indices[i+2];this.getVertex(o,va),this.getVertex(n,vb),this.getVertex(r,vc),Trimesh.computeNormal(vb,va,vc,e),t[i]=e.x,t[i+1]=e.y,t[i+2]=e.z}}updateEdges(){const e={},add=(t,s)=>{e[t<s?`${t}_${s}`:`${s}_${t}`]=!0};for(let e=0;e<this.indices.length/3;e++){const t=3*e,s=this.indices[t],i=this.indices[t+1],o=this.indices[t+2];add(s,i),add(i,o),add(o,s)}const t=Object.keys(e);this.edges=new Int16Array(2*t.length);for(let e=0;e<t.length;e++){const s=t[e].split("_");this.edges[2*e]=parseInt(s[0],10),this.edges[2*e+1]=parseInt(s[1],10)}}getEdgeVertex(e,t,s){const i=this.edges[2*e+(t?1:0)];this.getVertex(i,s)}getEdgeVector(e,t){const s=getEdgeVector_va,i=getEdgeVector_vb;this.getEdgeVertex(e,0,s),this.getEdgeVertex(e,1,i),i.vsub(s,t)}static computeNormal(e,t,s,i){t.vsub(e,ab),s.vsub(t,cb),cb.cross(ab,i),i.isZero()||i.normalize()}getVertex(e,t){const s=this.scale;return this._getUnscaledVertex(e,t),t.x*=s.x,t.y*=s.y,t.z*=s.z,t}_getUnscaledVertex(e,t){const s=3*e,i=this.vertices;return t.set(i[s],i[s+1],i[s+2])}getWorldVertex(e,t,s,i){return this.getVertex(e,i),Transform.pointToWorldFrame(t,s,i,i),i}getTriangleVertices(e,t,s,i){const o=3*e;this.getVertex(this.indices[o],t),this.getVertex(this.indices[o+1],s),this.getVertex(this.indices[o+2],i)}getNormal(e,t){const s=3*e;return t.set(this.normals[s],this.normals[s+1],this.normals[s+2])}calculateLocalInertia(e,t){this.computeLocalAABB(cli_aabb);const s=cli_aabb.upperBound.x-cli_aabb.lowerBound.x,i=cli_aabb.upperBound.y-cli_aabb.lowerBound.y,o=cli_aabb.upperBound.z-cli_aabb.lowerBound.z;return t.set(1/12*e*(2*i*2*i+2*o*2*o),1/12*e*(2*s*2*s+2*o*2*o),1/12*e*(2*i*2*i+2*s*2*s))}computeLocalAABB(e){const t=e.lowerBound,s=e.upperBound,i=this.vertices.length;this.vertices;const o=computeLocalAABB_worldVert;this.getVertex(0,o),t.copy(o),s.copy(o);for(let e=0;e!==i;e++)this.getVertex(e,o),o.x<t.x?t.x=o.x:o.x>s.x&&(s.x=o.x),o.y<t.y?t.y=o.y:o.y>s.y&&(s.y=o.y),o.z<t.z?t.z=o.z:o.z>s.z&&(s.z=o.z)}updateAABB(){this.computeLocalAABB(this.aabb)}updateBoundingSphereRadius(){let e=0;const t=this.vertices,s=new Vec3;for(let i=0,o=t.length/3;i!==o;i++){this.getVertex(i,s);const t=s.lengthSquared();t>e&&(e=t)}this.boundingSphereRadius=Math.sqrt(e)}calculateWorldAABB(e,t,s,i){const o=calculateWorldAABB_frame,n=calculateWorldAABB_aabb;o.position=e,o.quaternion=t,this.aabb.toWorldFrame(o,n),s.copy(n.lowerBound),i.copy(n.upperBound)}volume(){return 4*Math.PI*this.boundingSphereRadius/3}static createTorus(e,t,s,i,o){void 0===e&&(e=1),void 0===t&&(t=.5),void 0===s&&(s=8),void 0===i&&(i=6),void 0===o&&(o=2*Math.PI);const n=[],r=[];for(let r=0;r<=s;r++)for(let l=0;l<=i;l++){const h=l/i*o,d=r/s*Math.PI*2,p=(e+t*Math.cos(d))*Math.cos(h),u=(e+t*Math.cos(d))*Math.sin(h),m=t*Math.sin(d);n.push(p,u,m)}for(let e=1;e<=s;e++)for(let t=1;t<=i;t++){const s=(i+1)*e+t-1,o=(i+1)*(e-1)+t-1,n=(i+1)*(e-1)+t,l=(i+1)*e+t;r.push(s,o,l),r.push(o,n,l)}return new Trimesh(n,r)}}const computeNormals_n=new Vec3,unscaledAABB=new AABB,getEdgeVector_va=new Vec3,getEdgeVector_vb=new Vec3,cb=new Vec3,ab=new Vec3,va=new Vec3,vb=new Vec3,vc=new Vec3,cli_aabb=new AABB,computeLocalAABB_worldVert=new Vec3,calculateWorldAABB_frame=new Transform,calculateWorldAABB_aabb=new AABB;class Solver{constructor(){this.equations=[]}solve(e,t){return 0}addEquation(e){!e.enabled||e.bi.isTrigger||e.bj.isTrigger||this.equations.push(e)}removeEquation(e){const t=this.equations,s=t.indexOf(e);-1!==s&&t.splice(s,1)}removeAllEquations(){this.equations.length=0}}class GSSolver extends Solver{constructor(){super(),this.iterations=10,this.tolerance=1e-7}solve(e,t){let s=0;const i=this.iterations,o=this.tolerance*this.tolerance,n=this.equations,r=n.length,l=t.bodies,h=l.length,d=e;let p,u,m,v,y,g;if(0!==r)for(let e=0;e!==h;e++)l[e].updateSolveMassProperties();const x=GSSolver_solve_invCs,f=GSSolver_solve_Bs,w=GSSolver_solve_lambda;x.length=r,f.length=r,w.length=r;for(let e=0;e!==r;e++){const t=n[e];w[e]=0,f[e]=t.computeB(d),x[e]=1/t.computeC()}if(0!==r){for(let e=0;e!==h;e++){const t=l[e],s=t.vlambda,i=t.wlambda;s.set(0,0,0),i.set(0,0,0)}for(s=0;s!==i;s++){v=0;for(let e=0;e!==r;e++){const t=n[e];p=f[e],u=x[e],g=w[e],y=t.computeGWlambda(),m=u*(p-y-t.eps*g),g+m<t.minForce?m=t.minForce-g:g+m>t.maxForce&&(m=t.maxForce-g),w[e]+=m,v+=m>0?m:-m,t.addToWlambda(m)}if(v*v<o)break}for(let e=0;e!==h;e++){const t=l[e],s=t.velocity,i=t.angularVelocity;t.vlambda.vmul(t.linearFactor,t.vlambda),s.vadd(t.vlambda,s),t.wlambda.vmul(t.angularFactor,t.wlambda),i.vadd(t.wlambda,i)}let e=n.length;const t=1/d;for(;e--;)n[e].multiplier=w[e]*t}return s}}const GSSolver_solve_lambda=[],GSSolver_solve_invCs=[],GSSolver_solve_Bs=[];class SplitSolver extends Solver{constructor(e){for(super(),this.iterations=10,this.tolerance=1e-7,this.subsolver=e,this.nodes=[],this.nodePool=[];this.nodePool.length<128;)this.nodePool.push(this.createNode())}createNode(){return{body:null,children:[],eqs:[],visited:!1}}solve(e,t){const s=SplitSolver_solve_nodes,i=this.nodePool,o=t.bodies,n=this.equations,r=n.length,l=o.length,h=this.subsolver;for(;i.length<l;)i.push(this.createNode());s.length=l;for(let e=0;e<l;e++)s[e]=i[e];for(let e=0;e!==l;e++){const t=s[e];t.body=o[e],t.children.length=0,t.eqs.length=0,t.visited=!1}for(let e=0;e!==r;e++){const t=n[e],i=o.indexOf(t.bi),r=o.indexOf(t.bj),l=s[i],h=s[r];l.children.push(h),l.eqs.push(t),h.children.push(l),h.eqs.push(t)}let d,p=0,u=SplitSolver_solve_eqs;h.tolerance=this.tolerance,h.iterations=this.iterations;const m=SplitSolver_solve_dummyWorld;for(;d=getUnvisitedNode(s);){u.length=0,m.bodies.length=0,bfs(d,visitFunc,m.bodies,u);const t=u.length;u=u.sort(sortById);for(let e=0;e!==t;e++)h.addEquation(u[e]);h.solve(e,m),h.removeAllEquations(),p++}return p}}const SplitSolver_solve_nodes=[],SplitSolver_solve_eqs=[],SplitSolver_solve_dummyWorld={bodies:[]},STATIC=Body.STATIC;function getUnvisitedNode(e){const t=e.length;for(let s=0;s!==t;s++){const t=e[s];if(!(t.visited||t.body.type&STATIC))return t}return!1}const queue=[];function bfs(e,t,s,i){for(queue.push(e),e.visited=!0,t(e,s,i);queue.length;){const e=queue.pop();let o;for(;o=getUnvisitedNode(e.children);)o.visited=!0,t(o,s,i),queue.push(o)}}function visitFunc(e,t,s){t.push(e.body);const i=e.eqs.length;for(let t=0;t!==i;t++){const i=e.eqs[t];s.includes(i)||s.push(i)}}function sortById(e,t){return t.id-e.id}class Pool{constructor(){this.objects=[],this.type=Object}release(){const e=arguments.length;for(let t=0;t!==e;t++)this.objects.push(t<0||arguments.length<=t?void 0:arguments[t]);return this}get(){return 0===this.objects.length?this.constructObject():this.objects.pop()}constructObject(){throw new Error("constructObject() not implemented in this Pool subclass yet!")}resize(e){const t=this.objects;for(;t.length>e;)t.pop();for(;t.length<e;)t.push(this.constructObject());return this}}class Vec3Pool extends Pool{constructor(){super(...arguments),this.type=Vec3}constructObject(){return new Vec3}}const COLLISION_TYPES={sphereSphere:Shape.types.SPHERE,spherePlane:Shape.types.SPHERE|Shape.types.PLANE,boxBox:Shape.types.BOX|Shape.types.BOX,sphereBox:Shape.types.SPHERE|Shape.types.BOX,planeBox:Shape.types.PLANE|Shape.types.BOX,convexConvex:Shape.types.CONVEXPOLYHEDRON,sphereConvex:Shape.types.SPHERE|Shape.types.CONVEXPOLYHEDRON,planeConvex:Shape.types.PLANE|Shape.types.CONVEXPOLYHEDRON,boxConvex:Shape.types.BOX|Shape.types.CONVEXPOLYHEDRON,sphereHeightfield:Shape.types.SPHERE|Shape.types.HEIGHTFIELD,boxHeightfield:Shape.types.BOX|Shape.types.HEIGHTFIELD,convexHeightfield:Shape.types.CONVEXPOLYHEDRON|Shape.types.HEIGHTFIELD,sphereParticle:Shape.types.PARTICLE|Shape.types.SPHERE,planeParticle:Shape.types.PLANE|Shape.types.PARTICLE,boxParticle:Shape.types.BOX|Shape.types.PARTICLE,convexParticle:Shape.types.PARTICLE|Shape.types.CONVEXPOLYHEDRON,cylinderCylinder:Shape.types.CYLINDER,sphereCylinder:Shape.types.SPHERE|Shape.types.CYLINDER,planeCylinder:Shape.types.PLANE|Shape.types.CYLINDER,boxCylinder:Shape.types.BOX|Shape.types.CYLINDER,convexCylinder:Shape.types.CONVEXPOLYHEDRON|Shape.types.CYLINDER,heightfieldCylinder:Shape.types.HEIGHTFIELD|Shape.types.CYLINDER,particleCylinder:Shape.types.PARTICLE|Shape.types.CYLINDER,sphereTrimesh:Shape.types.SPHERE|Shape.types.TRIMESH,planeTrimesh:Shape.types.PLANE|Shape.types.TRIMESH};class Narrowphase{get[COLLISION_TYPES.sphereSphere](){return this.sphereSphere}get[COLLISION_TYPES.spherePlane](){return this.spherePlane}get[COLLISION_TYPES.boxBox](){return this.boxBox}get[COLLISION_TYPES.sphereBox](){return this.sphereBox}get[COLLISION_TYPES.planeBox](){return this.planeBox}get[COLLISION_TYPES.convexConvex](){return this.convexConvex}get[COLLISION_TYPES.sphereConvex](){return this.sphereConvex}get[COLLISION_TYPES.planeConvex](){return this.planeConvex}get[COLLISION_TYPES.boxConvex](){return this.boxConvex}get[COLLISION_TYPES.sphereHeightfield](){return this.sphereHeightfield}get[COLLISION_TYPES.boxHeightfield](){return this.boxHeightfield}get[COLLISION_TYPES.convexHeightfield](){return this.convexHeightfield}get[COLLISION_TYPES.sphereParticle](){return this.sphereParticle}get[COLLISION_TYPES.planeParticle](){return this.planeParticle}get[COLLISION_TYPES.boxParticle](){return this.boxParticle}get[COLLISION_TYPES.convexParticle](){return this.convexParticle}get[COLLISION_TYPES.cylinderCylinder](){return this.convexConvex}get[COLLISION_TYPES.sphereCylinder](){return this.sphereConvex}get[COLLISION_TYPES.planeCylinder](){return this.planeConvex}get[COLLISION_TYPES.boxCylinder](){return this.boxConvex}get[COLLISION_TYPES.convexCylinder](){return this.convexConvex}get[COLLISION_TYPES.heightfieldCylinder](){return this.heightfieldCylinder}get[COLLISION_TYPES.particleCylinder](){return this.particleCylinder}get[COLLISION_TYPES.sphereTrimesh](){return this.sphereTrimesh}get[COLLISION_TYPES.planeTrimesh](){return this.planeTrimesh}constructor(e){this.contactPointPool=[],this.frictionEquationPool=[],this.result=[],this.frictionResult=[],this.v3pool=new Vec3Pool,this.world=e,this.currentContactMaterial=e.defaultContactMaterial,this.enableFrictionReduction=!1}createContactEquation(e,t,s,i,o,n){let r;this.contactPointPool.length?(r=this.contactPointPool.pop(),r.bi=e,r.bj=t):r=new ContactEquation(e,t),r.enabled=e.collisionResponse&&t.collisionResponse&&s.collisionResponse&&i.collisionResponse;const l=this.currentContactMaterial;r.restitution=l.restitution,r.setSpookParams(l.contactEquationStiffness,l.contactEquationRelaxation,this.world.dt);const h=s.material||e.material,d=i.material||t.material;return h&&d&&h.restitution>=0&&d.restitution>=0&&(r.restitution=h.restitution*d.restitution),r.si=o||s,r.sj=n||i,r}createFrictionEquationsFromContact(e,t){const s=e.bi,i=e.bj,o=e.si,n=e.sj,r=this.world,l=this.currentContactMaterial;let h=l.friction;const d=o.material||s.material,p=n.material||i.material;if(d&&p&&d.friction>=0&&p.friction>=0&&(h=d.friction*p.friction),h>0){const o=h*(r.frictionGravity||r.gravity).length();let n=s.invMass+i.invMass;n>0&&(n=1/n);const d=this.frictionEquationPool,p=d.length?d.pop():new FrictionEquation(s,i,o*n),u=d.length?d.pop():new FrictionEquation(s,i,o*n);return p.bi=u.bi=s,p.bj=u.bj=i,p.minForce=u.minForce=-o*n,p.maxForce=u.maxForce=o*n,p.ri.copy(e.ri),p.rj.copy(e.rj),u.ri.copy(e.ri),u.rj.copy(e.rj),e.ni.tangents(p.t,u.t),p.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),u.setSpookParams(l.frictionEquationStiffness,l.frictionEquationRelaxation,r.dt),p.enabled=u.enabled=e.enabled,t.push(p,u),!0}return!1}createFrictionFromAverage(e){let t=this.result[this.result.length-1];if(!this.createFrictionEquationsFromContact(t,this.frictionResult)||1===e)return;const s=this.frictionResult[this.frictionResult.length-2],i=this.frictionResult[this.frictionResult.length-1];averageNormal.setZero(),averageContactPointA.setZero(),averageContactPointB.setZero();const o=t.bi;t.bj;for(let s=0;s!==e;s++)t=this.result[this.result.length-1-s],t.bi!==o?(averageNormal.vadd(t.ni,averageNormal),averageContactPointA.vadd(t.ri,averageContactPointA),averageContactPointB.vadd(t.rj,averageContactPointB)):(averageNormal.vsub(t.ni,averageNormal),averageContactPointA.vadd(t.rj,averageContactPointA),averageContactPointB.vadd(t.ri,averageContactPointB));const n=1/e;averageContactPointA.scale(n,s.ri),averageContactPointB.scale(n,s.rj),i.ri.copy(s.ri),i.rj.copy(s.rj),averageNormal.normalize(),averageNormal.tangents(s.t,i.t)}getContacts(e,t,s,i,o,n,r){this.contactPointPool=o,this.frictionEquationPool=r,this.result=i,this.frictionResult=n;const l=tmpQuat1,h=tmpQuat2,d=tmpVec1,p=tmpVec2;for(let i=0,o=e.length;i!==o;i++){const o=e[i],n=t[i];let r=null;o.material&&n.material&&(r=s.getContactMaterial(o.material,n.material)||null);const u=o.type&Body.KINEMATIC&&n.type&Body.STATIC||o.type&Body.STATIC&&n.type&Body.KINEMATIC||o.type&Body.KINEMATIC&&n.type&Body.KINEMATIC;for(let e=0;e<o.shapes.length;e++){o.quaternion.mult(o.shapeOrientations[e],l),o.quaternion.vmult(o.shapeOffsets[e],d),d.vadd(o.position,d);const t=o.shapes[e];for(let e=0;e<n.shapes.length;e++){n.quaternion.mult(n.shapeOrientations[e],h),n.quaternion.vmult(n.shapeOffsets[e],p),p.vadd(n.position,p);const i=n.shapes[e];if(!(t.collisionFilterMask&i.collisionFilterGroup&&i.collisionFilterMask&t.collisionFilterGroup))continue;if(d.distanceTo(p)>t.boundingSphereRadius+i.boundingSphereRadius)continue;let m=null;t.material&&i.material&&(m=s.getContactMaterial(t.material,i.material)||null),this.currentContactMaterial=m||r||s.defaultContactMaterial;const v=this[t.type|i.type];if(v){let e=!1;e=t.type<i.type?v.call(this,t,i,d,p,l,h,o,n,t,i,u):v.call(this,i,t,p,d,h,l,n,o,t,i,u),e&&u&&(s.shapeOverlapKeeper.set(t.id,i.id),s.bodyOverlapKeeper.set(o.id,n.id))}}}}}sphereSphere(e,t,s,i,o,n,r,l,h,d,p){if(p)return s.distanceSquared(i)<(e.radius+t.radius)**2;const u=this.createContactEquation(r,l,e,t,h,d);i.vsub(s,u.ni),u.ni.normalize(),u.ri.copy(u.ni),u.rj.copy(u.ni),u.ri.scale(e.radius,u.ri),u.rj.scale(-t.radius,u.rj),u.ri.vadd(s,u.ri),u.ri.vsub(r.position,u.ri),u.rj.vadd(i,u.rj),u.rj.vsub(l.position,u.rj),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}spherePlane(e,t,s,i,o,n,r,l,h,d,p){const u=this.createContactEquation(r,l,e,t,h,d);if(u.ni.set(0,0,1),n.vmult(u.ni,u.ni),u.ni.negate(u.ni),u.ni.normalize(),u.ni.scale(e.radius,u.ri),s.vsub(i,point_on_plane_to_sphere),u.ni.scale(u.ni.dot(point_on_plane_to_sphere),plane_to_sphere_ortho),point_on_plane_to_sphere.vsub(plane_to_sphere_ortho,u.rj),-point_on_plane_to_sphere.dot(u.ni)<=e.radius){if(p)return!0;const e=u.ri,t=u.rj;e.vadd(s,e),e.vsub(r.position,e),t.vadd(i,t),t.vsub(l.position,t),this.result.push(u),this.createFrictionEquationsFromContact(u,this.frictionResult)}}boxBox(e,t,s,i,o,n,r,l,h,d,p){return e.convexPolyhedronRepresentation.material=e.material,t.convexPolyhedronRepresentation.material=t.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t.convexPolyhedronRepresentation,s,i,o,n,r,l,e,t,p)}sphereBox(e,t,s,i,o,n,r,l,h,d,p){const u=this.v3pool,m=sphereBox_sides;s.vsub(i,box_to_sphere),t.getSideNormals(m,n);const v=e.radius;let y=!1;const g=sphereBox_side_ns,x=sphereBox_side_ns1,f=sphereBox_side_ns2;let w=null,B=0,_=0,S=0,V=null;for(let e=0,t=m.length;e!==t&&!1===y;e++){const t=sphereBox_ns;t.copy(m[e]);const s=t.length();t.normalize();const i=box_to_sphere.dot(t);if(i<s+v&&i>0){const o=sphereBox_ns1,n=sphereBox_ns2;o.copy(m[(e+1)%3]),n.copy(m[(e+2)%3]);const r=o.length(),l=n.length();o.normalize(),n.normalize();const h=box_to_sphere.dot(o),d=box_to_sphere.dot(n);if(h<r&&h>-r&&d<l&&d>-l){const e=Math.abs(i-s-v);if((null===V||e<V)&&(V=e,_=h,S=d,w=s,g.copy(t),x.copy(o),f.copy(n),B++,p))return!0}}}if(B){y=!0;const o=this.createContactEquation(r,l,e,t,h,d);g.scale(-v,o.ri),o.ni.copy(g),o.ni.negate(o.ni),g.scale(w,g),x.scale(_,x),g.vadd(x,g),f.scale(S,f),g.vadd(f,o.rj),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(i,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}let A=u.get();const E=sphereBox_sphere_to_corner;for(let o=0;2!==o&&!y;o++)for(let n=0;2!==n&&!y;n++)for(let u=0;2!==u&&!y;u++)if(A.set(0,0,0),o?A.vadd(m[0],A):A.vsub(m[0],A),n?A.vadd(m[1],A):A.vsub(m[1],A),u?A.vadd(m[2],A):A.vsub(m[2],A),i.vadd(A,E),E.vsub(s,E),E.lengthSquared()<v*v){if(p)return!0;y=!0;const o=this.createContactEquation(r,l,e,t,h,d);o.ri.copy(E),o.ri.normalize(),o.ni.copy(o.ri),o.ri.scale(v,o.ri),o.rj.copy(A),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(i,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}u.release(A),A=null;const C=u.get(),T=u.get(),P=u.get(),I=u.get(),F=u.get(),R=m.length;for(let o=0;o!==R&&!y;o++)for(let n=0;n!==R&&!y;n++)if(o%3!=n%3){m[n].cross(m[o],C),C.normalize(),m[o].vadd(m[n],T),P.copy(s),P.vsub(T,P),P.vsub(i,P);const u=P.dot(C);C.scale(u,I);let g=0;for(;g===o%3||g===n%3;)g++;F.copy(s),F.vsub(I,F),F.vsub(T,F),F.vsub(i,F);const x=Math.abs(u),f=F.length();if(x<m[g].length()&&f<v){if(p)return!0;y=!0;const o=this.createContactEquation(r,l,e,t,h,d);T.vadd(I,o.rj),o.rj.copy(o.rj),F.negate(o.ni),o.ni.normalize(),o.ri.copy(o.rj),o.ri.vadd(i,o.ri),o.ri.vsub(s,o.ri),o.ri.normalize(),o.ri.scale(v,o.ri),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(i,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}}u.release(C,T,P,I,F)}planeBox(e,t,s,i,o,n,r,l,h,d,p){return t.convexPolyhedronRepresentation.material=t.material,t.convexPolyhedronRepresentation.collisionResponse=t.collisionResponse,t.convexPolyhedronRepresentation.id=t.id,this.planeConvex(e,t.convexPolyhedronRepresentation,s,i,o,n,r,l,e,t,p)}convexConvex(e,t,s,i,o,n,r,l,h,d,p,u,m){const v=convexConvex_sepAxis;if(!(s.distanceTo(i)>e.boundingSphereRadius+t.boundingSphereRadius)&&e.findSeparatingAxis(t,s,o,i,n,v,u,m)){const u=[],m=convexConvex_q;e.clipAgainstHull(s,o,t,i,n,v,-100,100,u);let y=0;for(let o=0;o!==u.length;o++){if(p)return!0;const n=this.createContactEquation(r,l,e,t,h,d),g=n.ri,x=n.rj;v.negate(n.ni),u[o].normal.negate(m),m.scale(u[o].depth,m),u[o].point.vadd(m,g),x.copy(u[o].point),g.vsub(s,g),x.vsub(i,x),g.vadd(s,g),g.vsub(r.position,g),x.vadd(i,x),x.vsub(l.position,x),this.result.push(n),y++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(n,this.frictionResult)}this.enableFrictionReduction&&y&&this.createFrictionFromAverage(y)}}sphereConvex(e,t,s,i,o,n,r,l,h,d,p){const u=this.v3pool;s.vsub(i,convex_to_sphere);const m=t.faceNormals,v=t.faces,y=t.vertices,g=e.radius;let x=!1;for(let o=0;o!==y.length;o++){const u=y[o],m=sphereConvex_worldCorner;n.vmult(u,m),i.vadd(m,m);const v=sphereConvex_sphereToCorner;if(m.vsub(s,v),v.lengthSquared()<g*g){if(p)return!0;x=!0;const o=this.createContactEquation(r,l,e,t,h,d);return o.ri.copy(v),o.ri.normalize(),o.ni.copy(o.ri),o.ri.scale(g,o.ri),m.vsub(i,o.rj),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(i,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),void this.createFrictionEquationsFromContact(o,this.frictionResult)}}for(let o=0,f=v.length;o!==f&&!1===x;o++){const f=m[o],w=v[o],B=sphereConvex_worldNormal;n.vmult(f,B);const _=sphereConvex_worldPoint;n.vmult(y[w[0]],_),_.vadd(i,_);const S=sphereConvex_worldSpherePointClosestToPlane;B.scale(-g,S),s.vadd(S,S);const V=sphereConvex_penetrationVec;S.vsub(_,V);const A=V.dot(B),E=sphereConvex_sphereToWorldPoint;if(s.vsub(_,E),A<0&&E.dot(B)>0){const o=[];for(let e=0,t=w.length;e!==t;e++){const t=u.get();n.vmult(y[w[e]],t),i.vadd(t,t),o.push(t)}if(pointInPolygon(o,B,s)){if(p)return!0;x=!0;const n=this.createContactEquation(r,l,e,t,h,d);B.scale(-g,n.ri),B.negate(n.ni);const m=u.get();B.scale(-A,m);const v=u.get();B.scale(-g,v),s.vsub(i,n.rj),n.rj.vadd(v,n.rj),n.rj.vadd(m,n.rj),n.rj.vadd(i,n.rj),n.rj.vsub(l.position,n.rj),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),u.release(m),u.release(v),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);for(let e=0,t=o.length;e!==t;e++)u.release(o[e]);return}for(let m=0;m!==w.length;m++){const v=u.get(),x=u.get();n.vmult(y[w[(m+1)%w.length]],v),n.vmult(y[w[(m+2)%w.length]],x),i.vadd(v,v),i.vadd(x,x);const f=sphereConvex_edge;x.vsub(v,f);const B=sphereConvex_edgeUnit;f.unit(B);const _=u.get(),S=u.get();s.vsub(v,S);const V=S.dot(B);B.scale(V,_),_.vadd(v,_);const A=u.get();if(_.vsub(s,A),V>0&&V*V<f.lengthSquared()&&A.lengthSquared()<g*g){if(p)return!0;const n=this.createContactEquation(r,l,e,t,h,d);_.vsub(i,n.rj),_.vsub(s,n.ni),n.ni.normalize(),n.ni.scale(g,n.ri),n.rj.vadd(i,n.rj),n.rj.vsub(l.position,n.rj),n.ri.vadd(s,n.ri),n.ri.vsub(r.position,n.ri),this.result.push(n),this.createFrictionEquationsFromContact(n,this.frictionResult);for(let e=0,t=o.length;e!==t;e++)u.release(o[e]);return u.release(v),u.release(x),u.release(_),u.release(A),void u.release(S)}u.release(v),u.release(x),u.release(_),u.release(A),u.release(S)}for(let e=0,t=o.length;e!==t;e++)u.release(o[e])}}}planeConvex(e,t,s,i,o,n,r,l,h,d,p){const u=planeConvex_v,m=planeConvex_normal;m.set(0,0,1),o.vmult(m,m);let v=0;const y=planeConvex_relpos;for(let o=0;o!==t.vertices.length;o++){u.copy(t.vertices[o]),n.vmult(u,u),i.vadd(u,u),u.vsub(s,y);if(m.dot(y)<=0){if(p)return!0;const o=this.createContactEquation(r,l,e,t,h,d),n=planeConvex_projected;m.scale(m.dot(y),n),u.vsub(n,n),n.vsub(s,o.ri),o.ni.copy(m),u.vsub(i,o.rj),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),o.rj.vadd(i,o.rj),o.rj.vsub(l.position,o.rj),this.result.push(o),v++,this.enableFrictionReduction||this.createFrictionEquationsFromContact(o,this.frictionResult)}}this.enableFrictionReduction&&v&&this.createFrictionFromAverage(v)}boxConvex(e,t,s,i,o,n,r,l,h,d,p){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexConvex(e.convexPolyhedronRepresentation,t,s,i,o,n,r,l,e,t,p)}sphereHeightfield(e,t,s,i,o,n,r,l,h,d,p){const u=t.data,m=e.radius,v=t.elementSize,y=sphereHeightfield_tmp2,g=sphereHeightfield_tmp1;Transform.pointToLocalFrame(i,n,s,g);let x=Math.floor((g.x-m)/v)-1,f=Math.ceil((g.x+m)/v)+1,w=Math.floor((g.y-m)/v)-1,B=Math.ceil((g.y+m)/v)+1;if(f<0||B<0||x>u.length||w>u[0].length)return;x<0&&(x=0),f<0&&(f=0),w<0&&(w=0),B<0&&(B=0),x>=u.length&&(x=u.length-1),f>=u.length&&(f=u.length-1),B>=u[0].length&&(B=u[0].length-1),w>=u[0].length&&(w=u[0].length-1);const _=[];t.getRectMinMax(x,w,f,B,_);const S=_[0],V=_[1];if(g.z-m>V||g.z+m<S)return;const A=this.result;for(let h=x;h<f;h++)for(let d=w;d<B;d++){const u=A.length;let m=!1;if(t.getConvexTrianglePillar(h,d,!1),Transform.pointToWorldFrame(i,n,t.pillarOffset,y),s.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(m=this.sphereConvex(e,t.pillarConvex,s,y,o,n,r,l,e,t,p)),p&&m)return!0;if(t.getConvexTrianglePillar(h,d,!0),Transform.pointToWorldFrame(i,n,t.pillarOffset,y),s.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(m=this.sphereConvex(e,t.pillarConvex,s,y,o,n,r,l,e,t,p)),p&&m)return!0;if(A.length-u>2)return}}boxHeightfield(e,t,s,i,o,n,r,l,h,d,p){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexHeightfield(e.convexPolyhedronRepresentation,t,s,i,o,n,r,l,e,t,p)}convexHeightfield(e,t,s,i,o,n,r,l,h,d,p){const u=t.data,m=t.elementSize,v=e.boundingSphereRadius,y=convexHeightfield_tmp2,g=convexHeightfield_faceList,x=convexHeightfield_tmp1;Transform.pointToLocalFrame(i,n,s,x);let f=Math.floor((x.x-v)/m)-1,w=Math.ceil((x.x+v)/m)+1,B=Math.floor((x.y-v)/m)-1,_=Math.ceil((x.y+v)/m)+1;if(w<0||_<0||f>u.length||B>u[0].length)return;f<0&&(f=0),w<0&&(w=0),B<0&&(B=0),_<0&&(_=0),f>=u.length&&(f=u.length-1),w>=u.length&&(w=u.length-1),_>=u[0].length&&(_=u[0].length-1),B>=u[0].length&&(B=u[0].length-1);const S=[];t.getRectMinMax(f,B,w,_,S);const V=S[0],A=S[1];if(!(x.z-v>A||x.z+v<V))for(let h=f;h<w;h++)for(let d=B;d<_;d++){let u=!1;if(t.getConvexTrianglePillar(h,d,!1),Transform.pointToWorldFrame(i,n,t.pillarOffset,y),s.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(u=this.convexConvex(e,t.pillarConvex,s,y,o,n,r,l,null,null,p,g,null)),p&&u)return!0;if(t.getConvexTrianglePillar(h,d,!0),Transform.pointToWorldFrame(i,n,t.pillarOffset,y),s.distanceTo(y)<t.pillarConvex.boundingSphereRadius+e.boundingSphereRadius&&(u=this.convexConvex(e,t.pillarConvex,s,y,o,n,r,l,null,null,p,g,null)),p&&u)return!0}}sphereParticle(e,t,s,i,o,n,r,l,h,d,p){const u=particleSphere_normal;u.set(0,0,1),i.vsub(s,u);if(u.lengthSquared()<=e.radius*e.radius){if(p)return!0;const s=this.createContactEquation(l,r,t,e,h,d);u.normalize(),s.rj.copy(u),s.rj.scale(e.radius,s.rj),s.ni.copy(u),s.ni.negate(s.ni),s.ri.set(0,0,0),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}planeParticle(e,t,s,i,o,n,r,l,h,d,p){const u=particlePlane_normal;u.set(0,0,1),r.quaternion.vmult(u,u);const m=particlePlane_relpos;i.vsub(r.position,m);if(u.dot(m)<=0){if(p)return!0;const s=this.createContactEquation(l,r,t,e,h,d);s.ni.copy(u),s.ni.negate(s.ni),s.ri.set(0,0,0);const o=particlePlane_projected;u.scale(u.dot(i),o),i.vsub(o,o),s.rj.copy(o),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}boxParticle(e,t,s,i,o,n,r,l,h,d,p){return e.convexPolyhedronRepresentation.material=e.material,e.convexPolyhedronRepresentation.collisionResponse=e.collisionResponse,this.convexParticle(e.convexPolyhedronRepresentation,t,s,i,o,n,r,l,e,t,p)}convexParticle(e,t,s,i,o,n,r,l,h,d,p){let u=-1;const m=convexParticle_penetratedFaceNormal,v=convexParticle_worldPenetrationVec;let y=null;const g=convexParticle_local;if(g.copy(i),g.vsub(s,g),o.conjugate(cqj),cqj.vmult(g,g),e.pointIsInside(g)){e.worldVerticesNeedsUpdate&&e.computeWorldVertices(s,o),e.worldFaceNormalsNeedsUpdate&&e.computeWorldFaceNormals(o);for(let t=0,s=e.faces.length;t!==s;t++){const s=[e.worldVertices[e.faces[t][0]]],o=e.worldFaceNormals[t];i.vsub(s[0],convexParticle_vertexToParticle);const n=-o.dot(convexParticle_vertexToParticle);if(null===y||Math.abs(n)<Math.abs(y)){if(p)return!0;y=n,u=t,m.copy(o)}}if(-1!==u){const o=this.createContactEquation(l,r,t,e,h,d);m.scale(y,v),v.vadd(i,v),v.vsub(s,v),o.rj.copy(v),m.negate(o.ni),o.ri.set(0,0,0);const n=o.ri,p=o.rj;n.vadd(i,n),n.vsub(l.position,n),p.vadd(s,p),p.vsub(r.position,p),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}else console.warn("Point found inside convex, but did not find penetrating face!")}}heightfieldCylinder(e,t,s,i,o,n,r,l,h,d,p){return this.convexHeightfield(t,e,i,s,n,o,l,r,h,d,p)}particleCylinder(e,t,s,i,o,n,r,l,h,d,p){return this.convexParticle(t,e,i,s,n,o,l,r,h,d,p)}sphereTrimesh(e,t,s,i,o,n,r,l,h,d,p){const u=sphereTrimesh_edgeVertexA,m=sphereTrimesh_edgeVertexB,v=sphereTrimesh_edgeVector,y=sphereTrimesh_edgeVectorUnit,g=sphereTrimesh_localSpherePos,x=sphereTrimesh_tmp,f=sphereTrimesh_localSphereAABB,w=sphereTrimesh_v2,B=sphereTrimesh_relpos,_=sphereTrimesh_triangles;Transform.pointToLocalFrame(i,n,s,g);const S=e.radius;f.lowerBound.set(g.x-S,g.y-S,g.z-S),f.upperBound.set(g.x+S,g.y+S,g.z+S),t.getTrianglesInAABB(f,_);const V=sphereTrimesh_v,A=e.radius*e.radius;for(let o=0;o<_.length;o++)for(let u=0;u<3;u++)if(t.getVertex(t.indices[3*_[o]+u],V),V.vsub(g,B),B.lengthSquared()<=A){if(w.copy(V),Transform.pointToWorldFrame(i,n,w,V),V.vsub(s,B),p)return!0;let o=this.createContactEquation(r,l,e,t,h,d);o.ni.copy(B),o.ni.normalize(),o.ri.copy(o.ni),o.ri.scale(e.radius,o.ri),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),o.rj.copy(V),o.rj.vsub(l.position,o.rj),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}for(let o=0;o<_.length;o++)for(let f=0;f<3;f++){t.getVertex(t.indices[3*_[o]+f],u),t.getVertex(t.indices[3*_[o]+(f+1)%3],m),m.vsub(u,v),g.vsub(m,x);const w=x.dot(v);g.vsub(u,x);let B=x.dot(v);if(B>0&&w<0){g.vsub(u,x),y.copy(v),y.normalize(),B=x.dot(y),y.scale(B,x),x.vadd(u,x);if(x.distanceTo(g)<e.radius){if(p)return!0;const o=this.createContactEquation(r,l,e,t,h,d);x.vsub(g,o.ni),o.ni.normalize(),o.ni.scale(e.radius,o.ri),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),Transform.pointToWorldFrame(i,n,x,x),x.vsub(l.position,o.rj),Transform.vectorToWorldFrame(n,o.ni,o.ni),Transform.vectorToWorldFrame(n,o.ri,o.ri),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}}}const E=sphereTrimesh_va,C=sphereTrimesh_vb,T=sphereTrimesh_vc,P=sphereTrimesh_normal;for(let o=0,u=_.length;o!==u;o++){t.getTriangleVertices(_[o],E,C,T),t.getNormal(_[o],P),g.vsub(E,x);let u=x.dot(P);if(P.scale(u,x),g.vsub(x,x),u=x.distanceTo(g),Ray.pointInTriangle(x,E,C,T)&&u<e.radius){if(p)return!0;let o=this.createContactEquation(r,l,e,t,h,d);x.vsub(g,o.ni),o.ni.normalize(),o.ni.scale(e.radius,o.ri),o.ri.vadd(s,o.ri),o.ri.vsub(r.position,o.ri),Transform.pointToWorldFrame(i,n,x,x),x.vsub(l.position,o.rj),Transform.vectorToWorldFrame(n,o.ni,o.ni),Transform.vectorToWorldFrame(n,o.ri,o.ri),this.result.push(o),this.createFrictionEquationsFromContact(o,this.frictionResult)}}_.length=0}planeTrimesh(e,t,s,i,o,n,r,l,h,d,p){const u=new Vec3,m=planeTrimesh_normal;m.set(0,0,1),o.vmult(m,m);for(let o=0;o<t.vertices.length/3;o++){t.getVertex(o,u);const v=new Vec3;v.copy(u),Transform.pointToWorldFrame(i,n,v,u);const y=planeTrimesh_relpos;u.vsub(s,y);if(m.dot(y)<=0){if(p)return!0;const s=this.createContactEquation(r,l,e,t,h,d);s.ni.copy(m);const i=planeTrimesh_projected;m.scale(y.dot(m),i),u.vsub(i,i),s.ri.copy(i),s.ri.vsub(r.position,s.ri),s.rj.copy(u),s.rj.vsub(l.position,s.rj),this.result.push(s),this.createFrictionEquationsFromContact(s,this.frictionResult)}}}}const averageNormal=new Vec3,averageContactPointA=new Vec3,averageContactPointB=new Vec3,tmpVec1=new Vec3,tmpVec2=new Vec3,tmpQuat1=new Quaternion,tmpQuat2=new Quaternion,planeTrimesh_normal=new Vec3,planeTrimesh_relpos=new Vec3,planeTrimesh_projected=new Vec3,sphereTrimesh_normal=new Vec3,sphereTrimesh_relpos=new Vec3;new Vec3;const sphereTrimesh_v=new Vec3,sphereTrimesh_v2=new Vec3,sphereTrimesh_edgeVertexA=new Vec3,sphereTrimesh_edgeVertexB=new Vec3,sphereTrimesh_edgeVector=new Vec3,sphereTrimesh_edgeVectorUnit=new Vec3,sphereTrimesh_localSpherePos=new Vec3,sphereTrimesh_tmp=new Vec3,sphereTrimesh_va=new Vec3,sphereTrimesh_vb=new Vec3,sphereTrimesh_vc=new Vec3,sphereTrimesh_localSphereAABB=new AABB,sphereTrimesh_triangles=[],point_on_plane_to_sphere=new Vec3,plane_to_sphere_ortho=new Vec3,pointInPolygon_edge=new Vec3,pointInPolygon_edge_x_normal=new Vec3,pointInPolygon_vtp=new Vec3;function pointInPolygon(e,t,s){let i=null;const o=e.length;for(let n=0;n!==o;n++){const r=e[n],l=pointInPolygon_edge;e[(n+1)%o].vsub(r,l);const h=pointInPolygon_edge_x_normal;l.cross(t,h);const d=pointInPolygon_vtp;s.vsub(r,d);const p=h.dot(d);if(!(null===i||p>0&&!0===i||p<=0&&!1===i))return!1;null===i&&(i=p>0)}return!0}const box_to_sphere=new Vec3,sphereBox_ns=new Vec3,sphereBox_ns1=new Vec3,sphereBox_ns2=new Vec3,sphereBox_sides=[new Vec3,new Vec3,new Vec3,new Vec3,new Vec3,new Vec3],sphereBox_sphere_to_corner=new Vec3,sphereBox_side_ns=new Vec3,sphereBox_side_ns1=new Vec3,sphereBox_side_ns2=new Vec3,convex_to_sphere=new Vec3,sphereConvex_edge=new Vec3,sphereConvex_edgeUnit=new Vec3,sphereConvex_sphereToCorner=new Vec3,sphereConvex_worldCorner=new Vec3,sphereConvex_worldNormal=new Vec3,sphereConvex_worldPoint=new Vec3,sphereConvex_worldSpherePointClosestToPlane=new Vec3,sphereConvex_penetrationVec=new Vec3,sphereConvex_sphereToWorldPoint=new Vec3;new Vec3,new Vec3;const planeConvex_v=new Vec3,planeConvex_normal=new Vec3,planeConvex_relpos=new Vec3,planeConvex_projected=new Vec3,convexConvex_sepAxis=new Vec3,convexConvex_q=new Vec3,particlePlane_normal=new Vec3,particlePlane_relpos=new Vec3,particlePlane_projected=new Vec3,particleSphere_normal=new Vec3,cqj=new Quaternion,convexParticle_local=new Vec3;new Vec3;const convexParticle_penetratedFaceNormal=new Vec3,convexParticle_vertexToParticle=new Vec3,convexParticle_worldPenetrationVec=new Vec3,convexHeightfield_tmp1=new Vec3,convexHeightfield_tmp2=new Vec3,convexHeightfield_faceList=[0],sphereHeightfield_tmp1=new Vec3,sphereHeightfield_tmp2=new Vec3;class OverlapKeeper{constructor(){this.current=[],this.previous=[]}getKey(e,t){if(t<e){const s=t;t=e,e=s}return e<<16|t}set(e,t){const s=this.getKey(e,t),i=this.current;let o=0;for(;s>i[o];)o++;if(s!==i[o]){for(let e=i.length-1;e>=o;e--)i[e+1]=i[e];i[o]=s}}tick(){const e=this.current;this.current=this.previous,this.previous=e,this.current.length=0}getDiff(e,t){const s=this.current,i=this.previous,o=s.length,n=i.length;let r=0;for(let t=0;t<o;t++){let o=!1;const n=s[t];for(;n>i[r];)r++;o=n===i[r],o||unpackAndPush(e,n)}r=0;for(let e=0;e<n;e++){let o=!1;const n=i[e];for(;n>s[r];)r++;o=s[r]===n,o||unpackAndPush(t,n)}}}function unpackAndPush(e,t){e.push((4294901760&t)>>16,65535&t)}const getKey=(e,t)=>e<t?`${e}-${t}`:`${t}-${e}`;class TupleDictionary{constructor(){this.data={keys:[]}}get(e,t){const s=getKey(e,t);return this.data[s]}set(e,t,s){const i=getKey(e,t);this.get(e,t)||this.data.keys.push(i),this.data[i]=s}delete(e,t){const s=getKey(e,t),i=this.data.keys.indexOf(s);-1!==i&&this.data.keys.splice(i,1),delete this.data[s]}reset(){const e=this.data,t=e.keys;for(;t.length>0;){delete e[t.pop()]}}}class World extends EventTarget{constructor(e){void 0===e&&(e={}),super(),this.dt=-1,this.allowSleep=!!e.allowSleep,this.contacts=[],this.frictionEquations=[],this.quatNormalizeSkip=void 0!==e.quatNormalizeSkip?e.quatNormalizeSkip:0,this.quatNormalizeFast=void 0!==e.quatNormalizeFast&&e.quatNormalizeFast,this.time=0,this.stepnumber=0,this.default_dt=1/60,this.nextId=0,this.gravity=new Vec3,e.gravity&&this.gravity.copy(e.gravity),e.frictionGravity&&(this.frictionGravity=new Vec3,this.frictionGravity.copy(e.frictionGravity)),this.broadphase=void 0!==e.broadphase?e.broadphase:new NaiveBroadphase,this.bodies=[],this.hasActiveBodies=!1,this.solver=void 0!==e.solver?e.solver:new GSSolver,this.constraints=[],this.narrowphase=new Narrowphase(this),this.collisionMatrix=new ArrayCollisionMatrix,this.collisionMatrixPrevious=new ArrayCollisionMatrix,this.bodyOverlapKeeper=new OverlapKeeper,this.shapeOverlapKeeper=new OverlapKeeper,this.contactmaterials=[],this.contactMaterialTable=new TupleDictionary,this.defaultMaterial=new Material("default"),this.defaultContactMaterial=new ContactMaterial(this.defaultMaterial,this.defaultMaterial,{friction:.3,restitution:0}),this.doProfiling=!1,this.profile={solve:0,makeContactConstraints:0,broadphase:0,integrate:0,narrowphase:0},this.accumulator=0,this.subsystems=[],this.addBodyEvent={type:"addBody",body:null},this.removeBodyEvent={type:"removeBody",body:null},this.idToBodyMap={},this.broadphase.setWorld(this)}getContactMaterial(e,t){return this.contactMaterialTable.get(e.id,t.id)}collisionMatrixTick(){const e=this.collisionMatrixPrevious;this.collisionMatrixPrevious=this.collisionMatrix,this.collisionMatrix=e,this.collisionMatrix.reset(),this.bodyOverlapKeeper.tick(),this.shapeOverlapKeeper.tick()}addConstraint(e){this.constraints.push(e)}removeConstraint(e){const t=this.constraints.indexOf(e);-1!==t&&this.constraints.splice(t,1)}rayTest(e,t,s){s instanceof RaycastResult?this.raycastClosest(e,t,{skipBackfaces:!0},s):this.raycastAll(e,t,{skipBackfaces:!0},s)}raycastAll(e,t,s,i){return void 0===s&&(s={}),s.mode=Ray.ALL,s.from=e,s.to=t,s.callback=i,tmpRay.intersectWorld(this,s)}raycastAny(e,t,s,i){return void 0===s&&(s={}),s.mode=Ray.ANY,s.from=e,s.to=t,s.result=i,tmpRay.intersectWorld(this,s)}raycastClosest(e,t,s,i){return void 0===s&&(s={}),s.mode=Ray.CLOSEST,s.from=e,s.to=t,s.result=i,tmpRay.intersectWorld(this,s)}addBody(e){this.bodies.includes(e)||(e.index=this.bodies.length,this.bodies.push(e),e.world=this,e.initPosition.copy(e.position),e.initVelocity.copy(e.velocity),e.timeLastSleepy=this.time,e instanceof Body&&(e.initAngularVelocity.copy(e.angularVelocity),e.initQuaternion.copy(e.quaternion)),this.collisionMatrix.setNumObjects(this.bodies.length),this.addBodyEvent.body=e,this.idToBodyMap[e.id]=e,this.dispatchEvent(this.addBodyEvent))}removeBody(e){e.world=null;const t=this.bodies.length-1,s=this.bodies,i=s.indexOf(e);if(-1!==i){s.splice(i,1);for(let e=0;e!==s.length;e++)s[e].index=e;this.collisionMatrix.setNumObjects(t),this.removeBodyEvent.body=e,delete this.idToBodyMap[e.id],this.dispatchEvent(this.removeBodyEvent)}}getBodyById(e){return this.idToBodyMap[e]}getShapeById(e){const t=this.bodies;for(let s=0;s<t.length;s++){const i=t[s].shapes;for(let t=0;t<i.length;t++){const s=i[t];if(s.id===e)return s}}return null}addContactMaterial(e){this.contactmaterials.push(e),this.contactMaterialTable.set(e.materials[0].id,e.materials[1].id,e)}removeContactMaterial(e){const t=this.contactmaterials.indexOf(e);-1!==t&&(this.contactmaterials.splice(t,1),this.contactMaterialTable.delete(e.materials[0].id,e.materials[1].id))}fixedStep(e,t){void 0===e&&(e=1/60),void 0===t&&(t=10);const s=performance.now()/1e3;if(this.lastCallTime){const i=s-this.lastCallTime;this.step(e,i,t)}else this.step(e,void 0,t);this.lastCallTime=s}step(e,t,s){if(void 0===s&&(s=10),void 0===t)this.internalStep(e),this.time+=e;else{this.accumulator+=t;const i=performance.now();let o=0;for(;this.accumulator>=e&&o<s&&(this.internalStep(e),this.accumulator-=e,o++,!(performance.now()-i>1e3*e)););this.accumulator=this.accumulator%e;const n=this.accumulator/e;for(let e=0;e!==this.bodies.length;e++){const t=this.bodies[e];t.previousPosition.lerp(t.position,n,t.interpolatedPosition),t.previousQuaternion.slerp(t.quaternion,n,t.interpolatedQuaternion),t.previousQuaternion.normalize()}this.time+=t}}internalStep(e){this.dt=e;const t=this.contacts,s=World_step_p1,i=World_step_p2,o=this.bodies.length,n=this.bodies,r=this.solver,l=this.gravity,h=this.doProfiling,d=this.profile,p=Body.DYNAMIC;let u=-1/0;const m=this.constraints,v=World_step_frictionEquationPool;l.length();const y=l.x,g=l.y,x=l.z;let f=0;for(h&&(u=performance.now()),f=0;f!==o;f++){const e=n[f];if(e.type===p){const t=e.force,s=e.mass;t.x+=s*y,t.y+=s*g,t.z+=s*x}}for(let e=0,t=this.subsystems.length;e!==t;e++)this.subsystems[e].update();h&&(u=performance.now()),s.length=0,i.length=0,this.broadphase.collisionPairs(this,s,i),h&&(d.broadphase=performance.now()-u);let w=m.length;for(f=0;f!==w;f++){const e=m[f];if(!e.collideConnected)for(let t=s.length-1;t>=0;t-=1)(e.bodyA===s[t]&&e.bodyB===i[t]||e.bodyB===s[t]&&e.bodyA===i[t])&&(s.splice(t,1),i.splice(t,1))}this.collisionMatrixTick(),h&&(u=performance.now());const B=World_step_oldContacts,_=t.length;for(f=0;f!==_;f++)B.push(t[f]);t.length=0;const S=this.frictionEquations.length;for(f=0;f!==S;f++)v.push(this.frictionEquations[f]);for(this.frictionEquations.length=0,this.narrowphase.getContacts(s,i,this,t,B,this.frictionEquations,v),h&&(d.narrowphase=performance.now()-u),h&&(u=performance.now()),f=0;f<this.frictionEquations.length;f++)r.addEquation(this.frictionEquations[f]);const V=t.length;for(let e=0;e!==V;e++){const s=t[e],i=s.bi,o=s.bj,n=s.si,l=s.sj;let h;if(h=i.material&&o.material&&this.getContactMaterial(i.material,o.material)||this.defaultContactMaterial,h.friction,i.material&&o.material&&(i.material.friction>=0&&o.material.friction>=0&&(i.material.friction,o.material.friction),i.material.restitution>=0&&o.material.restitution>=0&&(s.restitution=i.material.restitution*o.material.restitution)),r.addEquation(s),i.allowSleep&&i.type===Body.DYNAMIC&&i.sleepState===Body.SLEEPING&&o.sleepState===Body.AWAKE&&o.type!==Body.STATIC){o.velocity.lengthSquared()+o.angularVelocity.lengthSquared()>=2*o.sleepSpeedLimit**2&&(i.wakeUpAfterNarrowphase=!0)}if(o.allowSleep&&o.type===Body.DYNAMIC&&o.sleepState===Body.SLEEPING&&i.sleepState===Body.AWAKE&&i.type!==Body.STATIC){i.velocity.lengthSquared()+i.angularVelocity.lengthSquared()>=2*i.sleepSpeedLimit**2&&(o.wakeUpAfterNarrowphase=!0)}this.collisionMatrix.set(i,o,!0),this.collisionMatrixPrevious.get(i,o)||(World_step_collideEvent.body=o,World_step_collideEvent.contact=s,i.dispatchEvent(World_step_collideEvent),World_step_collideEvent.body=i,o.dispatchEvent(World_step_collideEvent)),this.bodyOverlapKeeper.set(i.id,o.id),this.shapeOverlapKeeper.set(n.id,l.id)}for(this.emitContactEvents(),h&&(d.makeContactConstraints=performance.now()-u,u=performance.now()),f=0;f!==o;f++){const e=n[f];e.wakeUpAfterNarrowphase&&(e.wakeUp(),e.wakeUpAfterNarrowphase=!1)}for(w=m.length,f=0;f!==w;f++){const e=m[f];e.update();for(let t=0,s=e.equations.length;t!==s;t++){const s=e.equations[t];r.addEquation(s)}}r.solve(e,this),h&&(d.solve=performance.now()-u),r.removeAllEquations();const A=Math.pow;for(f=0;f!==o;f++){const t=n[f];if(t.type&p){const s=A(1-t.linearDamping,e),i=t.velocity;i.scale(s,i);const o=t.angularVelocity;if(o){const s=A(1-t.angularDamping,e);o.scale(s,o)}}}this.dispatchEvent(World_step_preStepEvent),h&&(u=performance.now());const E=this.stepnumber%(this.quatNormalizeSkip+1)==0,C=this.quatNormalizeFast;for(f=0;f!==o;f++)n[f].integrate(e,E,C);this.clearForces(),this.broadphase.dirty=!0,h&&(d.integrate=performance.now()-u),this.stepnumber+=1,this.dispatchEvent(World_step_postStepEvent);let T=!0;if(this.allowSleep)for(T=!1,f=0;f!==o;f++){const e=n[f];e.sleepTick(this.time),e.sleepState!==Body.SLEEPING&&(T=!0)}this.hasActiveBodies=T}emitContactEvents(){const e=this.hasAnyEventListener("beginContact"),t=this.hasAnyEventListener("endContact");if((e||t)&&this.bodyOverlapKeeper.getDiff(additions,removals),e){for(let e=0,t=additions.length;e<t;e+=2)beginContactEvent.bodyA=this.getBodyById(additions[e]),beginContactEvent.bodyB=this.getBodyById(additions[e+1]),this.dispatchEvent(beginContactEvent);beginContactEvent.bodyA=beginContactEvent.bodyB=null}if(t){for(let e=0,t=removals.length;e<t;e+=2)endContactEvent.bodyA=this.getBodyById(removals[e]),endContactEvent.bodyB=this.getBodyById(removals[e+1]),this.dispatchEvent(endContactEvent);endContactEvent.bodyA=endContactEvent.bodyB=null}additions.length=removals.length=0;const s=this.hasAnyEventListener("beginShapeContact"),i=this.hasAnyEventListener("endShapeContact");if((s||i)&&this.shapeOverlapKeeper.getDiff(additions,removals),s){for(let e=0,t=additions.length;e<t;e+=2){const t=this.getShapeById(additions[e]),s=this.getShapeById(additions[e+1]);beginShapeContactEvent.shapeA=t,beginShapeContactEvent.shapeB=s,t&&(beginShapeContactEvent.bodyA=t.body),s&&(beginShapeContactEvent.bodyB=s.body),this.dispatchEvent(beginShapeContactEvent)}beginShapeContactEvent.bodyA=beginShapeContactEvent.bodyB=beginShapeContactEvent.shapeA=beginShapeContactEvent.shapeB=null}if(i){for(let e=0,t=removals.length;e<t;e+=2){const t=this.getShapeById(removals[e]),s=this.getShapeById(removals[e+1]);endShapeContactEvent.shapeA=t,endShapeContactEvent.shapeB=s,t&&(endShapeContactEvent.bodyA=t.body),s&&(endShapeContactEvent.bodyB=s.body),this.dispatchEvent(endShapeContactEvent)}endShapeContactEvent.bodyA=endShapeContactEvent.bodyB=endShapeContactEvent.shapeA=endShapeContactEvent.shapeB=null}}clearForces(){const e=this.bodies,t=e.length;for(let s=0;s!==t;s++){const t=e[s];t.force,t.torque,t.force.set(0,0,0),t.torque.set(0,0,0)}}}new AABB;const tmpRay=new Ray,performance={};if(!performance.now){let e=Date.now();performance.timing&&performance.timing.navigationStart&&(e=performance.timing.navigationStart),performance.now=()=>Date.now()-e}new Vec3;const World_step_postStepEvent={type:"postStep"},World_step_preStepEvent={type:"preStep"},World_step_collideEvent={type:Body.COLLIDE_EVENT_NAME,body:null,contact:null},World_step_oldContacts=[],World_step_frictionEquationPool=[],World_step_p1=[],World_step_p2=[],additions=[],removals=[],beginContactEvent={type:"beginContact",bodyA:null,bodyB:null},endContactEvent={type:"endContact",bodyA:null,bodyB:null},beginShapeContactEvent={type:"beginShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null},endShapeContactEvent={type:"endShapeContact",bodyA:null,bodyB:null,shapeA:null,shapeB:null};module.exports={AABB:AABB,ArrayCollisionMatrix:ArrayCollisionMatrix,BODY_SLEEP_STATES:BODY_SLEEP_STATES,BODY_TYPES:BODY_TYPES,Body:Body,Box:Box,Broadphase:Broadphase,COLLISION_TYPES:COLLISION_TYPES,ConeTwistConstraint:ConeTwistConstraint,Constraint:Constraint,ContactEquation:ContactEquation,ContactMaterial:ContactMaterial,ConvexPolyhedron:ConvexPolyhedron,Cylinder:Cylinder,DistanceConstraint:DistanceConstraint,Equation:Equation,EventTarget:EventTarget,FrictionEquation:FrictionEquation,GSSolver:GSSolver,GridBroadphase:GridBroadphase,Heightfield:Heightfield,HingeConstraint:HingeConstraint,JacobianElement:JacobianElement,LockConstraint:LockConstraint,Mat3:Mat3,Material:Material,NaiveBroadphase:NaiveBroadphase,Narrowphase:Narrowphase,ObjectCollisionMatrix:ObjectCollisionMatrix,Particle:Particle,Plane:Plane,PointToPointConstraint:PointToPointConstraint,Pool:Pool,Quaternion:Quaternion,RAY_MODES:RAY_MODES,Ray:Ray,RaycastResult:RaycastResult,RaycastVehicle:RaycastVehicle,RigidVehicle:RigidVehicle,RotationalEquation:RotationalEquation,RotationalMotorEquation:RotationalMotorEquation,SAPBroadphase:SAPBroadphase,SHAPE_TYPES:SHAPE_TYPES,SPHSystem:SPHSystem,Shape:Shape,Solver:Solver,Sphere:Sphere,SplitSolver:SplitSolver,Spring:Spring,Transform:Transform,Trimesh:Trimesh,Vec3:Vec3,Vec3Pool:Vec3Pool,WheelInfo:WheelInfo,World:World};